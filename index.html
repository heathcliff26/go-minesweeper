
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>minesweeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/difficulty.go (100.0%)</option>
				
				<option value="file1">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/game.go (98.3%)</option>
				
				<option value="file2">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/utils.go (100.0%)</option>
				
				<option value="file3">github.com/heathcliff26/go-minesweeper/pkg/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package minesweeper

const (
        DifficultyClassic      = iota
        DifficultyBeginner     = iota
        DifficultyIntermediate = iota
        DifficultyExpert       = iota
)

// Represent a difficulty setting for the Game
type Difficulty struct {
        Name     string
        Row, Col int
        Mines    int
}

// Pre-defined difficulties
var difficulties []Difficulty = []Difficulty{
        {
                Name:  "Classic",
                Row:   8,
                Col:   8,
                Mines: 9,
        },
        {
                Name:  "Beginner",
                Row:   9,
                Col:   9,
                Mines: 10,
        },
        {
                Name:  "Intermediate",
                Row:   16,
                Col:   16,
                Mines: 40,
        },
        {
                Name:  "Expert",
                Row:   16,
                Col:   30,
                Mines: 99,
        },
}

// Exposes pre-defined difficulties in a way that does not allow the original array to be modified
func Difficulties() []Difficulty <span class="cov8" title="1">{
        list := make([]Difficulty, len(difficulties))
        copy(list, difficulties)
        return list
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package minesweeper

import (
        "log"

        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

// Represents the content of a field.
// Can be a mine, unknown or the number of mines in the neighboring fields
type FieldContent int

const (
        Mine    FieldContent = -1
        Unknown FieldContent = -2
)

// Represents a single field in a minefield
type Field struct {
        Checked bool
        Content FieldContent
}

// Status contains the current state of the game known to the player.
// As such it will always be a copy and needs to be it's own type, despite the
// overlapping similarities.
// It does not support any of the functions that Game does.
// It is safe to write to Status, as it is merely a copy.
type Status struct {
        Field    [][]Field
        GameOver bool
        GameWon  bool
}

// Struct for holding the game
type Game struct {
        Field      [][]Field
        Difficulty Difficulty
        GameOver   bool
        GameWon    bool
}

// Create a new game with mines seeded randomly in the map, with the exception of the given position.
func NewGameWithSafePos(d Difficulty, p Pos) *Game <span class="cov8" title="1">{
        g := &amp;Game{
                Field:      utils.Make2D[Field](d.Row, d.Col),
                Difficulty: d,
                GameOver:   false,
                GameWon:    false,
        }

        mines := CreateMines(d, p)
        for _, mine := range mines </span><span class="cov8" title="1">{
                g.Field[mine.X][mine.Y].Content = Mine
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; d.Row; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; d.Col; y++ </span><span class="cov8" title="1">{
                        if g.Field[x][y].Content == Mine </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">c := 0
                        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                                        if x+m &lt; 0 || x+m &gt;= d.Row || y+n &lt; 0 || y+n &gt;= d.Row </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if g.Field[x+m][y+n].Content == Mine </span><span class="cov8" title="1">{
                                                c++
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">g.Field[x][y].Content = FieldContent(c)</span>
                }
        }

        <span class="cov8" title="1">return g</span>
}

// Check a given field and recursevly reveal all neighboring fields that should be revield.
// Returns the resulting new status of the game
func (g *Game) CheckField(p Pos) *Status <span class="cov8" title="1">{
        if g.GameOver || g.GameWon </span><span class="cov0" title="0">{
                return g.Status()
        }</span>

        <span class="cov8" title="1">g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content == Mine </span><span class="cov8" title="1">{
                g.GameOver = true
                return g.Status()
        }</span>

        <span class="cov8" title="1">g.RevealField(p)

        return g.Status()</span>
}

// Recursive function to reveal all neighbouring fields that can be safely reveald.
// Stops when a field has not exactly zero neighbouring mines
func (g *Game) RevealField(p Pos) <span class="cov8" title="1">{
        log.Printf("Reveal tile (%d, %d), content: %d\n", p.X, p.Y, g.Field[p.X][p.Y].Content)

        g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content != 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Revealing neigbhours of (%d, %d)\n", p.X, p.Y)

        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        if m == 0 &amp;&amp; n == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">i := Pos{p.X + m, p.Y + n}
                        if g.outOfBounds(i) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if !g.Field[i.X][i.Y].Checked </span><span class="cov8" title="1">{
                                g.RevealField(i)
                        }</span>
                }
        }
}

// Check if the given position is out of bounds
func (g *Game) outOfBounds(p Pos) bool <span class="cov8" title="1">{
        d := g.Difficulty
        return p.X &lt; 0 || p.X &gt; d.Row-1 || p.Y &lt; 0 || p.Y &gt; d.Col-1
}</span>

// Returns the current status of the game. Only contains the knowledge a player should have.
func (g *Game) Status() *Status <span class="cov8" title="1">{
        d := g.Difficulty
        s := &amp;Status{
                Field:    utils.Make2D[Field](d.Row, d.Col),
                GameOver: g.GameOver,
        }

        wasWon := g.GameWon
        isWon := true

        for x := 0; x &lt; d.Row; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; d.Col; y++ </span><span class="cov8" title="1">{
                        s.Field[x][y].Checked = g.Field[x][y].Checked
                        if g.Field[x][y].Checked || g.GameOver || wasWon </span><span class="cov8" title="1">{
                                s.Field[x][y].Content = g.Field[x][y].Content
                        }</span> else<span class="cov8" title="1"> {
                                s.Field[x][y].Content = Unknown
                        }</span>
                        <span class="cov8" title="1">if !g.Field[x][y].Checked &amp;&amp; g.Field[x][y].Content != Mine </span><span class="cov8" title="1">{
                                isWon = false
                        }</span>
                }
        }

        <span class="cov8" title="1">g.GameWon, s.GameWon = isWon, isWon

        if g.GameWon != wasWon </span><span class="cov8" title="1">{
                for x := 0; x &lt; d.Row; x++ </span><span class="cov8" title="1">{
                        copy(s.Field[x], g.Field[x])
                }</span>
        }

        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package minesweeper

import (
        "fmt"
        "math/rand"
        "slices"
)

// Represent a position in the minefield
type Pos struct {
        X, Y int
}

// Returns a string representation of the position
func (p Pos) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}</span>

// Randomly create mines for the given difficulty.
// Does not create a mine on the given position.
func CreateMines(d Difficulty, p Pos) []Pos <span class="cov8" title="1">{
        mines := make([]Pos, 0, d.Mines+1)

        mines = append(mines, p)
        for i := 0; i &lt; d.Mines; i++ </span><span class="cov8" title="1">{
                p = RandomPos(d.Row, d.Col)
                for slices.Contains(mines, p) </span><span class="cov8" title="1">{
                        p = RandomPos(d.Row, d.Col)
                }</span>
                <span class="cov8" title="1">mines = append(mines, p)</span>
        }
        <span class="cov8" title="1">return mines[1:]</span>
}

// Returns a random position inside the provided limits
func RandomPos(maxX, maxY int) Pos <span class="cov8" title="1">{
        return Pos{
                X: rand.Intn(maxX),
                Y: rand.Intn(maxY),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package utils

// Create a new, empty 2 dimensional array of the given type and dimensions.
func Make2D[T any](x, y int) [][]T <span class="cov8" title="1">{
        if x &lt; 1 || y &lt; 1 </span><span class="cov8" title="1">{
                return [][]T{}
        }</span>

        <span class="cov8" title="1">matrix := make([][]T, x)
        rows := make([]T, x*y)

        for i := 0; i &lt; x; i++ </span><span class="cov8" title="1">{
                matrix[i] = rows[i*y : (i+1)*y]
        }</span>
        <span class="cov8" title="1">return matrix</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
