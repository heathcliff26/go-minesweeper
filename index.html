
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/go-minesweeper/pkg/app/app.go (48.0%)</option>
				
				<option value="file1">github.com/heathcliff26/go-minesweeper/pkg/app/button.go (100.0%)</option>
				
				<option value="file2">github.com/heathcliff26/go-minesweeper/pkg/app/counter.go (100.0%)</option>
				
				<option value="file3">github.com/heathcliff26/go-minesweeper/pkg/app/filedialog/dialog.go (0.0%)</option>
				
				<option value="file4">github.com/heathcliff26/go-minesweeper/pkg/app/grid.go (99.0%)</option>
				
				<option value="file5">github.com/heathcliff26/go-minesweeper/pkg/app/locations/locations.go (63.2%)</option>
				
				<option value="file6">github.com/heathcliff26/go-minesweeper/pkg/app/locations/locations_linux.go (85.7%)</option>
				
				<option value="file7">github.com/heathcliff26/go-minesweeper/pkg/app/preferences.go (92.1%)</option>
				
				<option value="file8">github.com/heathcliff26/go-minesweeper/pkg/app/theme.go (100.0%)</option>
				
				<option value="file9">github.com/heathcliff26/go-minesweeper/pkg/app/tile.go (100.0%)</option>
				
				<option value="file10">github.com/heathcliff26/go-minesweeper/pkg/app/timer.go (100.0%)</option>
				
				<option value="file11">github.com/heathcliff26/go-minesweeper/pkg/app/utils.go (54.8%)</option>
				
				<option value="file12">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/difficulty.go (100.0%)</option>
				
				<option value="file13">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/errors.go (50.0%)</option>
				
				<option value="file14">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/game.go (99.0%)</option>
				
				<option value="file15">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/save.go (84.6%)</option>
				
				<option value="file16">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/status.go (100.0%)</option>
				
				<option value="file17">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/utils.go (100.0%)</option>
				
				<option value="file18">github.com/heathcliff26/go-minesweeper/pkg/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "log/slog"
        "os"
        "time"

        "fyne.io/fyne/v2"
        fApp "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/data/binding"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/pkg/app/filedialog"
        "github.com/heathcliff26/go-minesweeper/pkg/app/locations"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

const DEFAULT_DIFFICULTY = minesweeper.DifficultyBeginner

const DEFAULT_GAME_ALGORITHM = GameAlgorithmSafeArea

const DEFAULT_AUTOSOLVE_DELAY = 500 * time.Millisecond

// Used to change the new app function for testing
var newApp = fApp.New

// Struct representing the current app.
// There should only ever be a single instance during runtime.
type App struct {
        app            fyne.App
        main           fyne.Window
        Version        Version
        grid           *MinesweeperGrid
        difficulties   []*fyne.MenuItem
        gameMenu       []*fyne.MenuItem
        assistedMode   *fyne.MenuItem
        gameAlgorithms []*fyne.MenuItem
}

// Create a new App
func New() *App <span class="cov3" title="3">{
        preferences, err := LoadPreferences()
        if err != nil </span><span class="cov2" title="2">{
                slog.Info("Failed to load preferences, falling back to defaults", "err", err)
        }</span> else<span class="cov1" title="1"> {
                slog.Debug("Loaded preferences", "preferences", preferences)
        }</span>

        <span class="cov3" title="3">app := newApp()
        version := getVersion(app)
        main := app.NewWindow(version.Name)
        app.Settings().SetTheme(mainTheme{})

        a := &amp;App{
                app:     app,
                main:    main,
                Version: version,
        }
        a.main.SetTitle(version.Name)
        a.makeMenu(preferences)
        a.NewGrid(preferences.Difficulty())
        a.setGameAlgorithm(preferences.GameAlgorithm)

        a.main.SetFixedSize(true)
        a.main.Show()

        return a</span>
}

// Simply calls app.Run()
func (a *App) Run() <span class="cov0" title="0">{
        a.app.Run()

        preferences := CreatePreferencesFromApp(a)
        err := preferences.Save()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to save preferences for next time", "err", err)
        }</span> else<span class="cov0" title="0"> {
                slog.Info("Saved preferences")
        }</span>
}

// Create the main menu bar
func (a *App) makeMenu(preferences Preferences) <span class="cov3" title="3">{
        // Can't assign grid functions directly, as the instance of grid may change
        newGameOption := fyne.NewMenuItem("New", func() </span><span class="cov2" title="2">{
                a.grid.NewGame()
        }</span>)
        <span class="cov3" title="3">replayOption := fyne.NewMenuItem("Replay", func() </span><span class="cov2" title="2">{
                a.grid.Replay()
        }</span>)
        <span class="cov3" title="3">loadOption := fyne.NewMenuItem("Load", a.loadSave)
        saveOption := fyne.NewMenuItem("Save", a.saveGame)
        a.gameMenu = []*fyne.MenuItem{newGameOption, replayOption, fyne.NewMenuItemSeparator(), loadOption, saveOption}
        gameMenu := fyne.NewMenu("Game", a.gameMenu...)

        difficulties := minesweeper.Difficulties()
        diffItems := make([]*fyne.MenuItem, 0, len(difficulties)+2)
        for _, d := range difficulties </span><span class="cov7" title="12">{
                item := fyne.NewMenuItem(d.Name, nil)
                item.Action = func() </span><span class="cov4" title="4">{
                        if item.Checked </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov4" title="4">for _, i := range a.difficulties </span><span class="cov9" title="24">{
                                i.Checked = (i.Label == d.Name)
                        }</span>
                        <span class="cov4" title="4">a.NewGrid(d)</span>
                }
                <span class="cov7" title="12">item.Checked = (d == preferences.Difficulty())
                diffItems = append(diffItems, item)</span>
        }
        <span class="cov3" title="3">diffItems = append(diffItems, fyne.NewMenuItemSeparator())
        diffItems = append(diffItems, fyne.NewMenuItem("Custom", a.customDifficultyDialog))
        a.difficulties = diffItems
        diffMenu := fyne.NewMenu("Difficulties", diffItems...)

        a.assistedMode = fyne.NewMenuItem("      Assisted Mode", func() </span><span class="cov2" title="2">{
                a.assistedMode.Checked = !a.assistedMode.Checked
                a.grid.AssistedMode = a.assistedMode.Checked
                if a.grid.AssistedMode &amp;&amp; a.grid.Game != nil </span><span class="cov0" title="0">{
                        go a.grid.updateFromStatus(a.grid.Game.Status())
                }</span>
        })
        <span class="cov3" title="3">a.assistedMode.Checked = preferences.AssistedMode
        a.gameAlgorithms = make([]*fyne.MenuItem, 3)
        a.gameAlgorithms[0] = fyne.NewMenuItem("Safe Position", func() </span><span class="cov1" title="1">{
                a.setGameAlgorithm(GameAlgorithmSafePos)
        }</span>)
        <span class="cov3" title="3">a.gameAlgorithms[1] = fyne.NewMenuItem("Safe Area", func() </span><span class="cov1" title="1">{
                a.setGameAlgorithm(GameAlgorithmSafeArea)
        }</span>)
        <span class="cov3" title="3">a.gameAlgorithms[2] = fyne.NewMenuItem("Solvable", func() </span><span class="cov1" title="1">{
                a.setGameAlgorithm(GameAlgorithmSolvable)
        }</span>)
        <span class="cov3" title="3">gameAlgorithmSubMenu := fyne.NewMenuItem("Creation Algorithm", nil)
        gameAlgorithmSubMenu.ChildMenu = fyne.NewMenu("Creation Algorithm", a.gameAlgorithms...)
        autosolve := fyne.NewMenuItem("Autosolve", func() </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        if !a.grid.Autosolve(DEFAULT_AUTOSOLVE_DELAY) </span><span class="cov0" title="0">{
                                dialog.ShowInformation("Autosolve", "Failed to run autosolve, please ensure that a game is currently running.", a.main)
                        }</span>
                }()
        })
        <span class="cov3" title="3">optionsMenu := fyne.NewMenu("Options", a.assistedMode, gameAlgorithmSubMenu, autosolve)

        hint := fyne.NewMenuItem("Hint", func() </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        if !a.grid.Hint() </span><span class="cov0" title="0">{
                                dialog.NewInformation("No hint found", "Could not find any hints to give.", a.main).Show()
                        }</span>
                }()
        })
        <span class="cov3" title="3">about := fyne.NewMenuItem("About", func() </span><span class="cov0" title="0">{
                vInfo := dialog.NewCustom(a.Version.Name, "close", getVersionContent(a.Version), a.main)
                vInfo.Show()
        }</span>)
        <span class="cov3" title="3">helpMenu := fyne.NewMenu("Help", hint, about)

        a.main.SetMainMenu(fyne.NewMainMenu(gameMenu, diffMenu, optionsMenu, helpMenu))</span>
}

// Update the content of the app and resize the window to make it fit
func (a *App) setContent() <span class="cov7" title="11">{
        content := container.NewPadded(a.grid.GetCanvasObject())
        content.Resize(content.MinSize())

        a.main.SetContent(content)
        a.main.Resize(content.MinSize())
}</span>

// Show a dialog for setting a custom difficulty
func (a *App) customDifficultyDialog() <span class="cov0" title="0">{
        mines := minesweeper.DifficultyMineMin
        row, col := minesweeper.DifficultyRowColMin, minesweeper.DifficultyRowColMin

        mineItem := widget.NewFormItem("Mines", widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;mines))))
        rowItem := widget.NewFormItem("Rows", widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;row))))
        colItem := widget.NewFormItem("Columns", widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;col))))

        content := widget.NewForm(mineItem, rowItem, colItem)

        diffDialog := dialog.NewCustomConfirm("Custom Difficulty", "ok", "cancel", content, func(ok bool) </span><span class="cov0" title="0">{
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">d, err := minesweeper.NewCustomDifficulty(mines, row, col)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">for _, i := range a.difficulties </span><span class="cov0" title="0">{
                        i.Checked = (i.Label == "Custom")
                }</span>
                <span class="cov0" title="0">a.NewGrid(d)</span>
        }, a.main)
        <span class="cov0" title="0">diffDialog.Show()</span>
}

func (a *App) loadSave() <span class="cov0" title="0">{
        saveDir, err := locations.SaveFolder()
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>

        <span class="cov0" title="0">filedialog.FileOpen("Open Savegame", saveDir, []string{minesweeper.SaveFileExtension}, func(path string, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>
                <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">save, err := minesweeper.LoadSave(path)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">for _, i := range a.difficulties </span><span class="cov0" title="0">{
                        i.Checked = (i.Label == save.Data.Difficulty.Name)
                }</span>
                <span class="cov0" title="0">a.NewGrid(save.Data.Difficulty)

                a.grid.Game = save.Game()</span>
        })
}

func (a *App) saveGame() <span class="cov0" title="0">{
        if a.grid.Game == nil </span><span class="cov0" title="0">{
                d := dialog.NewInformation("Can't save game", "You need to first start a game before you can save it.", a.main)
                d.Show()
                return
        }</span>
        <span class="cov0" title="0">saveDir, err := locations.SaveFolder()
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>

        <span class="cov0" title="0">filedialog.FileSave("Save Game", saveDir, []string{minesweeper.SaveFileExtension}, func(path string, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>
                <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">err = os.Remove(path)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">save, err := a.grid.Game.ToSave()
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">err = save.Save(path)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>
        })
}

func (a *App) NewGrid(d minesweeper.Difficulty) <span class="cov7" title="10">{
        a.grid = NewMinesweeperGrid(d, a.assistedMode.Checked)
        for i, item := range a.gameAlgorithms </span><span class="cov10" title="30">{
                if item.Checked </span><span class="cov6" title="7">{
                        a.grid.GameAlgorithm = i
                }</span>
        }
        <span class="cov7" title="10">a.setContent()</span>
}

func (a *App) setGameAlgorithm(id int) <span class="cov5" title="6">{
        for i, item := range a.gameAlgorithms </span><span class="cov8" title="18">{
                item.Checked = i == id
        }</span>
        <span class="cov5" title="6">a.grid.GameAlgorithm = id</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/widget"
)

// Custom implementation for a button that is only portraied by text.
// The text is fully configurable by exposing the backing label.
type Button struct {
        widget.BaseWidget

        Label  *canvas.Text
        Action func()
}

// Create a new button from the given text, color and function
func NewButton(text string, color color.Color, action func()) *Button <span class="cov10" title="52">{
        b := &amp;Button{
                Label:  canvas.NewText(text, color),
                Action: action,
        }
        b.ExtendBaseWidget(b)
        return b
}</span>

// Function to create renderer needed to implement widget
func (b *Button) CreateRenderer() fyne.WidgetRenderer <span class="cov7" title="19">{
        return widget.NewSimpleRenderer(b.Label)
}</span>

// Left click action
func (b *Button) Tapped(_ *fyne.PointEvent) <span class="cov1" title="1">{
        b.Action()
}</span>

// Right click action, currently not implemented or exposed
func (b *Button) TappedSecondary(_ *fyne.PointEvent) {<span class="cov0" title="0">}</span>

// Set label text to the given string and refresh widget
func (b *Button) SetText(text string) <span class="cov7" title="17">{
        b.Label.Text = text
        fyne.Do(b.Refresh)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "fmt"
        "strconv"
        "sync"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
)

// Displays a counter that can be increased and decreased
type Counter struct {
        Label *canvas.Text
        Count int

        lock sync.Mutex
}

// Create new counter
func NewCounter(count int) *Counter <span class="cov8" title="53">{
        return &amp;Counter{
                Label: newGridLabel(strconv.Itoa(count)),
                Count: count,
        }
}</span>

// Set the count to a specific number
func (m *Counter) SetCount(c int) <span class="cov5" title="12">{
        m.lock.Lock()
        defer m.lock.Unlock()

        m.Count = c
        m.refresh()
}</span>

// Redraw the counter from the current count
func (m *Counter) refresh() <span class="cov10" title="147">{
        if m.Count &lt; 0 </span><span class="cov1" title="1">{
                m.Label.Text = "00"
        }</span> else<span class="cov9" title="146"> {
                m.Label.Text = fmt.Sprintf("%02d", m.Count)
        }</span>
        <span class="cov10" title="147">fyne.Do(m.Label.Refresh)</span>
}

// Increase the counter
func (m *Counter) Inc() <span class="cov6" title="17">{
        m.lock.Lock()
        defer m.lock.Unlock()

        m.Count++
        m.refresh()
}</span>

// Decrease the counter
func (m *Counter) Dec() <span class="cov9" title="118">{
        m.lock.Lock()
        defer m.lock.Unlock()

        m.Count--
        m.refresh()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package filedialog

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/storage"
)

const (
        DialogHeight = 800
        DialogWidth  = 600
)

// Show a file open dialog in a new window and return path.
func FileOpen(name string, startLocation string, extensions []string, cb func(string, error)) <span class="cov0" title="0">{
        w := fyne.CurrentApp().NewWindow(name)
        d := dialog.NewFileOpen(func(uri fyne.URIReadCloser, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        cb("", err)
                        return
                }</span>
                <span class="cov0" title="0">if uri == nil </span><span class="cov0" title="0">{
                        cb("", err)
                        return
                }</span>

                <span class="cov0" title="0">cb(uri.URI().Path(), nil)</span>
        }, w)

        <span class="cov0" title="0">err := showFileDialog(startLocation, extensions, d, w)
        if err != nil </span><span class="cov0" title="0">{
                cb("", err)
        }</span>
}

// Show a file save dialog in a new window and return path.
func FileSave(name string, startLocation string, extensions []string, cb func(string, error)) <span class="cov0" title="0">{
        w := fyne.CurrentApp().NewWindow(name)
        d := dialog.NewFileSave(func(uri fyne.URIWriteCloser, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        cb("", err)
                        return
                }</span>
                <span class="cov0" title="0">if uri == nil </span><span class="cov0" title="0">{
                        cb("", err)
                        return
                }</span>
                <span class="cov0" title="0">defer uri.Close()
                cb(uri.URI().Path(), nil)</span>
        }, w)

        <span class="cov0" title="0">err := showFileDialog(startLocation, extensions, d, w)
        if err != nil </span><span class="cov0" title="0">{
                cb("", err)
        }</span>
}

// Set a file dialogs location to the given directory.
// When dir is empty, uses current directory.
// Returns error on failure.
func setDialogLocationToDir(dir string, d *dialog.FileDialog) error <span class="cov0" title="0">{
        uri, err := storage.ParseURI("file://" + dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">listURI, err := storage.ListerForURI(uri)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">d.SetLocation(listURI)

        return nil</span>
}

func showFileDialog(startLocation string, extensions []string, d *dialog.FileDialog, w fyne.Window) error <span class="cov0" title="0">{
        d.SetFilter(storage.NewExtensionFileFilter(extensions))

        err := setDialogLocationToDir(startLocation, d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.SetOnClosed(func() </span><span class="cov0" title="0">{
                w.Close()
        }</span>)

        <span class="cov0" title="0">w.Resize(fyne.NewSize(DialogHeight, DialogWidth))
        w.SetFixedSize(true)
        d.Resize(fyne.NewSize(DialogHeight, DialogWidth))
        fyne.Do(func() </span><span class="cov0" title="0">{
                w.Show()
                d.Show()
        }</span>)

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "image/color"
        "log/slog"
        "sync"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

var (
        GridLabelColor = color.RGBA{240, 10, 20, alpha}
)

const (
        GridLabelSize float32 = 40

        ResetDefaultText          = "🙂"
        ResetGameOverText         = "☠"
        ResetGameWonText          = "😎"
        ResetTextSize     float32 = 40
)

const (
        GameAlgorithmSafePos = iota
        GameAlgorithmSafeArea
        GameAlgorithmSolvable
)

const (
        ChunkSize = 10
)

// Graphical display for a minesweeper game
type MinesweeperGrid struct {
        Tiles         [][]*Tile
        Difficulty    minesweeper.Difficulty
        Game          minesweeper.Game
        AssistedMode  bool
        GameAlgorithm int

        Timer       *Timer
        MineCount   *Counter
        ResetButton *Button

        lUpdate sync.Mutex
        lGame   sync.Mutex

        testChannel chan string
}

// Create a new grid suitable for the give difficulty
func NewMinesweeperGrid(d minesweeper.Difficulty, assistedMode bool) *MinesweeperGrid <span class="cov4" title="51">{
        tiles := utils.Make2D[*Tile](d.Row, d.Col)
        grid := &amp;MinesweeperGrid{
                Tiles:         tiles,
                Difficulty:    d,
                AssistedMode:  assistedMode,
                GameAlgorithm: DEFAULT_GAME_ALGORITHM,
                Timer:         NewTimer(),
                MineCount:     NewCounter(d.Mines),
        }
        grid.ResetButton = NewButton(ResetDefaultText, color.RGBA{}, grid.NewGame)
        grid.ResetButton.Label.TextSize = ResetTextSize

        for x := 0; x &lt; grid.Row(); x++ </span><span class="cov6" title="607">{
                for y := 0; y &lt; grid.Col(); y++ </span><span class="cov8" title="10205">{
                        grid.Tiles[x][y] = NewTile(x, y, grid)
                }</span>
        }

        <span class="cov4" title="51">return grid</span>
}

// Get the graphical representation of the grid
func (g *MinesweeperGrid) GetCanvasObject() fyne.CanvasObject <span class="cov2" title="11">{
        mineCount := container.NewHBox(layout.NewSpacer(), container.NewCenter(newBorder(g.MineCount.Label)))
        reset := container.NewCenter(g.ResetButton)
        timer := container.NewHBox(container.NewCenter(newBorder(g.Timer.Label)), layout.NewSpacer())

        head := newBorder(container.NewGridWithColumns(3, mineCount, reset, timer))

        rows := make([]fyne.CanvasObject, len(g.Tiles))

        for x := 0; x &lt; g.Row(); x++ </span><span class="cov4" title="111">{
                col := make([]fyne.CanvasObject, g.Col())
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov6" title="1431">{
                        col[y] = g.Tiles[x][y]
                }</span>
                <span class="cov4" title="111">rows[x] = container.NewGridWithColumns(g.Col(), col...)</span>
        }
        <span class="cov2" title="11">body := newBorder(container.NewGridWithRows(g.Row(), rows...))
        return container.NewVBox(head, body)</span>
}

// Called by the child tiles to signal they have been tapped.
// Checks the given tile and then updates the display according to the new state.
// Starts a new game when no game is currently running.
func (g *MinesweeperGrid) TappedTile(pos minesweeper.Pos) <span class="cov5" title="234">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        if g.Game == nil </span><span class="cov3" title="16">{
                switch g.GameAlgorithm </span>{
                case GameAlgorithmSafePos:<span class="cov1" title="1">
                        g.Game = minesweeper.NewGameWithSafePos(g.Difficulty, pos)</span>
                case GameAlgorithmSafeArea:<span class="cov3" title="13">
                        g.Game = minesweeper.NewGameWithSafeArea(g.Difficulty, pos)</span>
                case GameAlgorithmSolvable:<span class="cov1" title="1">
                        g.Game = minesweeper.NewGameSolvable(g.Difficulty, pos)</span>
                default:<span class="cov1" title="1">
                        slog.Error("Unkown Algorithm for creating a new game", slog.Int("algorithm", g.GameAlgorithm))
                        return</span>
                }
        }
        <span class="cov5" title="233">if !g.Timer.Running() </span><span class="cov3" title="23">{
                g.Timer.Start()
        }</span>

        <span class="cov5" title="233">slog.Info("Checking field", slog.String("pos", pos.String()))

        s, changed := g.Game.CheckField(pos)
        if changed </span><span class="cov5" title="233">{
                slog.Debug("Checked field, updating tiles")
                g.updateFromStatus(s)
        }</span>

        <span class="cov5" title="233">if g.testChannel != nil </span><span class="cov1" title="1">{
                g.testChannel &lt;- "TappedTile"
        }</span>
}

// Called by the child tiles to reveal all neighbours when they have been double tapped
func (g *MinesweeperGrid) TapNeighbours(pos minesweeper.Pos) <span class="cov1" title="1">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        flags := minesweeper.FieldContent(0)
        posToCheck := make([]minesweeper.Pos, 0, 8)
        for m := -1; m &lt; 2; m++ </span><span class="cov1" title="3">{
                for n := -1; n &lt; 2; n++ </span><span class="cov2" title="9">{
                        p := pos
                        p.X += m
                        p.Y += n
                        if !g.OutOfBounds(p) </span><span class="cov2" title="9">{
                                if g.Tiles[p.X][p.Y].Flagged() </span><span class="cov1" title="1">{
                                        flags++
                                        continue</span>
                                }
                                <span class="cov2" title="8">if g.Tiles[p.X][p.Y].untappable() </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                                <span class="cov2" title="7">posToCheck = append(posToCheck, p)</span>
                        }
                }
        }

        <span class="cov1" title="1">if flags != g.Tiles[pos.X][pos.Y].Content() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">for _, p := range posToCheck </span><span class="cov2" title="7">{
                g.Game.CheckField(p)
        }</span>
        <span class="cov1" title="1">g.updateFromStatus(g.Game.Status())

        if g.testChannel != nil </span><span class="cov1" title="1">{
                g.testChannel &lt;- "TapNeighbours"
        }</span>
}

// Update the grid from the given status
func (g *MinesweeperGrid) updateFromStatus(s *minesweeper.Status) <span class="cov5" title="252">{
        if s == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov5" title="251">g.lUpdate.Lock()
        defer g.lUpdate.Unlock()

        var wg sync.WaitGroup

        if s.GameOver() || s.GameWon() </span><span class="cov2" title="6">{
                switch </span>{
                case s.GameWon():<span class="cov2" title="4">
                        slog.Info("Win")
                        g.ResetButton.SetText(ResetGameWonText)</span>
                case s.GameOver():<span class="cov1" title="2">
                        slog.Info("Game Over")
                        g.ResetButton.SetText(ResetGameOverText)</span>
                }
                <span class="cov2" title="6">g.Timer.Stop()</span>
        } else<span class="cov5" title="245"> if g.AssistedMode </span><span class="cov5" title="215">{
                wg.Add(2)
                slog.Debug("Creating Markers for Assisted Mode")
                go func() </span><span class="cov5" title="215">{
                        defer wg.Done()
                        for _, p := range s.ObviousMines() </span><span class="cov7" title="3962">{
                                g.Tiles[p.X][p.Y].Mark(HelpMarkingMine)
                        }</span>
                }()
                <span class="cov5" title="215">go func() </span><span class="cov5" title="215">{
                        defer wg.Done()
                        for _, p := range s.ObviousSafePos() </span><span class="cov7" title="2467">{
                                g.Tiles[p.X][p.Y].Mark(HelpMarkingSafe)
                        }</span>
                }()
        }

        <span class="cov5" title="251">for x := 0; x &lt;= g.Row()/ChunkSize; x++ </span><span class="cov6" title="462">{
                chunkSizeX := ChunkSize
                if x == g.Row()/ChunkSize </span><span class="cov5" title="251">{
                        if g.Row()%ChunkSize == 0 </span><span class="cov1" title="3">{
                                continue</span>
                        } else<span class="cov5" title="248"> {
                                chunkSizeX = g.Row() % ChunkSize
                        }</span>
                }
                <span class="cov6" title="459">startX := x * ChunkSize

                for y := 0; y &lt;= g.Col()/ChunkSize; y++ </span><span class="cov6" title="908">{
                        chunkSizeY := ChunkSize
                        if y == g.Col()/ChunkSize </span><span class="cov6" title="459">{
                                if g.Col()%ChunkSize == 0 </span><span class="cov3" title="13">{
                                        continue</span>
                                } else<span class="cov5" title="446"> {
                                        chunkSizeY = g.Col() % ChunkSize
                                }</span>
                        }

                        <span class="cov6" title="895">startY := y * ChunkSize

                        wg.Add(1)
                        go g.updateChunk(startX, startY, startX+chunkSizeX, startY+chunkSizeY, s, &amp;wg)</span>
                }
        }

        <span class="cov5" title="251">wg.Wait()
        slog.Debug("Finished Update")</span>
}

// Update a single chunk defined by the given dimensions
func (g *MinesweeperGrid) updateChunk(startX, startY, endX, endY int, s *minesweeper.Status, wg *sync.WaitGroup) <span class="cov6" title="895">{
        defer wg.Done()
        for x := startX; x &lt; endX; x++ </span><span class="cov8" title="7247">{
                for y := startY; y &lt; endY; y++ </span><span class="cov10" title="59114">{
                        if s.Field[x][y].Content == minesweeper.Unknown </span><span class="cov9" title="28797">{
                                continue</span>
                        }
                        <span class="cov9" title="30317">g.Tiles[x][y].SetField(s.Field[x][y])</span>
                }
        }
}

// Return the number of rows in the grid
func (g *MinesweeperGrid) Row() int <span class="cov7" title="3051">{
        return g.Difficulty.Row
}</span>

// Return the number of columns in the grid
func (g *MinesweeperGrid) Col() int <span class="cov9" title="28567">{
        return g.Difficulty.Col
}</span>

// Start a new game
func (g *MinesweeperGrid) NewGame() <span class="cov2" title="7">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        slog.Info("Preparing for new game")
        g.Game = nil
        g.Reset()
}</span>

// Replay the current game
func (g *MinesweeperGrid) Replay() <span class="cov1" title="3">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        slog.Info("Preparing for replay of current game")
        if g.Game != nil </span><span class="cov1" title="3">{
                g.Game.Replay()
        }</span>
        <span class="cov1" title="3">g.Reset()</span>
}

// Reset Grid
func (g *MinesweeperGrid) Reset() <span class="cov2" title="10">{
        g.lUpdate.Lock()
        defer g.lUpdate.Unlock()

        for x := 0; x &lt; g.Row(); x++ </span><span class="cov4" title="97">{
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov6" title="1209">{
                        g.Tiles[x][y].Reset()
                }</span>
        }
        <span class="cov2" title="10">g.MineCount.SetCount(g.Difficulty.Mines)
        g.Timer.Reset()
        g.ResetButton.SetText(ResetDefaultText)
        g.ResetButton.Refresh()
        slog.Debug("Reset grid")</span>
}

// Check if the given position is out of bounds.
// Calls Game.OutOfBounds(Pos)
func (g *MinesweeperGrid) OutOfBounds(p minesweeper.Pos) bool <span class="cov3" title="27">{
        return g.Game.OutOfBounds(p)
}</span>

// Display a single hint on the grid.
// Returns false if no hint could be displayed.
func (g *MinesweeperGrid) Hint() bool <span class="cov3" title="13">{
        g.lGame.Lock()

        if g.Game == nil </span><span class="cov1" title="1">{
                g.lGame.Unlock()
                return false
        }</span>
        <span class="cov3" title="12">s := g.Game.Status()

        g.lGame.Unlock()

        if s == nil || s.GameOver() || s.GameWon() </span><span class="cov1" title="2">{
                return false
        }</span>

        <span class="cov2" title="10">g.lUpdate.Lock()
        defer g.lUpdate.Unlock()

        for _, mine := range s.ObviousMines() </span><span class="cov4" title="44">{
                tile := g.Tiles[mine.X][mine.Y]
                if tile.Flagged() </span><span class="cov3" title="36">{
                        continue</span>
                }
                <span class="cov2" title="8">tile.Mark(HelpMarkingMine)
                return true</span>
        }
        <span class="cov1" title="2">safePos := s.ObviousSafePos()
        if len(safePos) &gt; 0 </span><span class="cov1" title="1">{
                g.Tiles[safePos[0].X][safePos[0].Y].Mark(HelpMarkingSafe)
                return true
        }</span>
        <span class="cov1" title="1">return false</span>
}

// Autosolve the current running game, delay is the time between steps
// Returns false if it can't run autosolve, otherwise true.
// If there are no steps to be taken, still
func (g *MinesweeperGrid) Autosolve(delay time.Duration) bool <span class="cov2" title="10">{
        g.lGame.Lock()

        if g.Game == nil </span><span class="cov1" title="1">{
                slog.Info("Autosolve failed because no game is running")
                g.lGame.Unlock()
                return false
        }</span>
        <span class="cov2" title="9">s := g.Game.Status()

        g.lGame.Unlock()

        if s == nil </span><span class="cov1" title="1">{
                slog.Info("Autosolve failed because game does not have a status yet")
                return false
        }</span>
        <span class="cov2" title="8">if s.GameWon() || s.GameOver() </span><span class="cov1" title="2">{
                slog.Info("Not running autosolve because the game is already over")
                return false
        }</span>

        <span class="cov2" title="6">oldAssistedModeStatus := g.AssistedMode
        g.AssistedMode = true
        defer func() </span><span class="cov2" title="6">{
                g.AssistedMode = oldAssistedModeStatus
        }</span>()
        <span class="cov2" title="6">g.updateFromStatus(s)

        for i, safePos := 0, s.ObviousSafePos(); len(safePos) &gt; 0 &amp;&amp; !s.GameOver() &amp;&amp; !s.GameWon(); safePos = s.ObviousSafePos() </span><span class="cov3" title="28">{
                mines := s.ObviousMines()

                slog.Debug("Autosolve: Checking safe positions", slog.Int("iteration", i))
                for _, p := range safePos </span><span class="cov5" title="223">{
                        if s.GameOver() || s.GameWon() </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov5" title="223">if g.Tiles[p.X][p.Y].Checked() </span><span class="cov3" title="22">{
                                continue</span>
                        }
                        <span class="cov5" title="201">g.TappedTile(p)
                        time.Sleep(delay)</span>
                }

                <span class="cov3" title="28">slog.Info("Autosolve: Flagging mines", slog.Int("iteration", i))
                for _, mine := range mines </span><span class="cov5" title="396">{
                        if s.GameOver() || s.GameWon() </span><span class="cov1" title="2">{
                                break</span>
                        }
                        <span class="cov5" title="394">tile := g.Tiles[mine.X][mine.Y]
                        tile.Flag(true)</span>
                }

                <span class="cov3" title="28">i++</span>
        }

        <span class="cov2" title="6">if s.GameOver() || s.GameWon() </span><span class="cov1" title="2">{
                slog.Debug("Autosolve finished")
                return true
        }</span>

        <span class="cov2" title="4">slog.Info("Autosolve: Flagging mines a final time")
        for _, mine := range s.ObviousMines() </span><span class="cov4" title="81">{
                tile := g.Tiles[mine.X][mine.Y]
                tile.Flag(true)
        }</span>

        <span class="cov2" title="4">slog.Debug("Autosolve finished")
        return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package locations

import (
        "log/slog"
        "os"
        "path/filepath"
)

const appName = "go-minesweeper"

const settingsFilename = "settings.yaml"

var saveFolder = ""

var settingsFile = ""

func SaveFolder() (string, error) <span class="cov3" title="2">{
        if saveFolder != "" </span><span class="cov1" title="1">{
                return saveFolder, nil
        }</span>

        <span class="cov1" title="1">var err error
        saveFolder, err = loadSaveFolderLocation()
        if err == nil </span><span class="cov1" title="1">{
                return saveFolder, os.MkdirAll(saveFolder, 0755)
        }</span>
        <span class="cov0" title="0">slog.Error("Failed to load save folder location, falling back to current directory", "err", err)

        return os.Getwd()</span>
}

func SettingsFile() (string, error) <span class="cov10" title="10">{
        if settingsFile != "" </span><span class="cov9" title="8">{
                return settingsFile, nil
        }</span>

        <span class="cov3" title="2">var err error
        settingsFile, err = loadSettingsFileLocation()
        if err == nil </span><span class="cov3" title="2">{
                return settingsFile, os.MkdirAll(filepath.Dir(settingsFile), 0755)
        }</span>
        <span class="cov0" title="0">slog.Error("Failed to load settings.yaml location, falling back to current directory", "err", err)

        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(pwd, settingsFilename), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//go:build linux

package locations

import (
        "os"
        "path/filepath"
)

func loadSaveFolderLocation() (string, error) <span class="cov8" title="3">{
        xdgDataHome := os.Getenv("XDG_DATA_HOME")
        if xdgDataHome != "" </span><span class="cov1" title="1">{
                return filepath.Join(xdgDataHome, "saves"), nil
        }</span>

        <span class="cov5" title="2">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="2">return filepath.Join(home, ".config", appName, "saves"), nil</span>
}

func loadSettingsFileLocation() (string, error) <span class="cov10" title="4">{
        xdgConfigHome := os.Getenv("XDG_CONFIG_HOME")
        if xdgConfigHome != "" </span><span class="cov1" title="1">{
                return filepath.Join(xdgConfigHome, settingsFilename), nil
        }</span>

        <span class="cov8" title="3">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="3">return filepath.Join(home, ".config", appName, settingsFilename), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "os"

        "github.com/heathcliff26/go-minesweeper/pkg/app/locations"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "sigs.k8s.io/yaml"
)

type Preferences struct {
        DifficultyInt int  `json:"difficulty"`
        AssistedMode  bool `json:"assistedMode"`
        GameAlgorithm int  `json:"gameAlgorithm"`
}

// Only used for testing, as we don't want to touch the actual file that might be on the system.
var overrideSettingsPath = ""

func defaultPreferences() Preferences <span class="cov8" title="11">{
        return Preferences{
                DifficultyInt: DEFAULT_DIFFICULTY,
                AssistedMode:  false,
                GameAlgorithm: DEFAULT_GAME_ALGORITHM,
        }
}</span>

// Load the preferences from the settings file.
// Return default values when an error occurs.
func LoadPreferences() (Preferences, error) <span class="cov6" title="7">{
        path, err := locations.SettingsFile()
        if err != nil </span><span class="cov0" title="0">{
                return defaultPreferences(), err
        }</span>
        <span class="cov6" title="7">if overrideSettingsPath != "" </span><span class="cov6" title="6">{
                path = overrideSettingsPath
        }</span>

        <span class="cov6" title="7">f, err := os.ReadFile(path)
        if err != nil </span><span class="cov4" title="3">{
                return defaultPreferences(), err
        }</span>

        <span class="cov5" title="4">p := defaultPreferences()
        err = yaml.Unmarshal(f, &amp;p)
        if err != nil </span><span class="cov1" title="1">{
                return defaultPreferences(), err
        }</span>

        <span class="cov4" title="3">return p, nil</span>
}

// Convert the current app state to preferences that can be saved.
func CreatePreferencesFromApp(app *App) Preferences <span class="cov3" title="2">{
        difficulty := DEFAULT_DIFFICULTY
        for i, d := range app.difficulties </span><span class="cov6" title="7">{
                if d.Checked </span><span class="cov1" title="1">{
                        difficulty = i
                        break</span>
                }
        }

        <span class="cov3" title="2">gameAlgorithm := DEFAULT_GAME_ALGORITHM
        for i, algorithm := range app.gameAlgorithms </span><span class="cov5" title="4">{
                if algorithm.Checked </span><span class="cov1" title="1">{
                        gameAlgorithm = i
                        break</span>
                }
        }

        <span class="cov3" title="2">return Preferences{
                DifficultyInt: difficulty,
                AssistedMode:  app.assistedMode.Checked,
                GameAlgorithm: gameAlgorithm,
        }</span>
}

// Convert the saved difficulty number to an actual difficulty
func (p Preferences) Difficulty() minesweeper.Difficulty <span class="cov10" title="19">{
        difficulties := minesweeper.Difficulties()

        if p.DifficultyInt &lt; 0 || p.DifficultyInt &gt;= len(difficulties) </span><span class="cov3" title="2">{
                return difficulties[DEFAULT_DIFFICULTY]
        }</span>
        <span class="cov9" title="17">return difficulties[p.DifficultyInt]</span>
}

// Save the preferences to the settings file
func (p Preferences) Save() error <span class="cov1" title="1">{
        path, err := locations.SettingsFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if overrideSettingsPath != "" </span><span class="cov1" title="1">{
                path = overrideSettingsPath
        }</span>

        <span class="cov1" title="1">data, err := yaml.Marshal(&amp;p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return os.WriteFile(path, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/theme"
)

const colorNameTileDefault = "tileDefault"

var (
        lightGray                    = color.RGBA{211, 211, 211, alpha}
        tileDefaultColorVariantLight = color.RGBA{180, 180, 180, alpha}
        tileDefaultColorVariantDark  = color.Gray16{32767}
)

var (
        // Ensure there are compile errors if the theme interface is not implemented
        _ fyne.Theme = mainTheme{}
        _ fyne.Theme = borderTheme{}
)

type mainTheme struct{}

func (mainTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color <span class="cov8" title="9548">{
        if variant == theme.VariantLight &amp;&amp; name == theme.ColorNameBackground </span><span class="cov1" title="3">{
                return lightGray
        }</span>
        <span class="cov8" title="9545">if name == colorNameTileDefault </span><span class="cov8" title="9036">{
                switch variant </span>{
                case theme.VariantLight:<span class="cov1" title="1">
                        return tileDefaultColorVariantLight</span>
                case theme.VariantDark:<span class="cov1" title="1">
                        return tileDefaultColorVariantDark</span>
                }
        }
        <span class="cov8" title="9543">return theme.DefaultTheme().Color(name, variant)</span>
}

func (mainTheme) Font(style fyne.TextStyle) fyne.Resource <span class="cov2" title="6">{
        return theme.DefaultTheme().Font(style)
}</span>

func (mainTheme) Icon(name fyne.ThemeIconName) fyne.Resource <span class="cov1" title="3">{
        return theme.DefaultTheme().Icon(name)
}</span>

func (mainTheme) Size(name fyne.ThemeSizeName) float32 <span class="cov10" title="74355">{
        return theme.DefaultTheme().Size(name)
}</span>

type borderTheme struct {
        mainTheme
}

func (borderTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color <span class="cov6" title="510">{
        if name == theme.ColorNameShadow </span><span class="cov5" title="156">{
                switch variant </span>{
                case theme.VariantLight:<span class="cov1" title="1">
                        return color.Black</span>
                case theme.VariantDark:<span class="cov1" title="1">
                        return color.White</span>
                }
        }
        <span class="cov5" title="508">return mainTheme{}.Color(name, variant)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">//go:generate fyne bundle --package assets --prefix Resource -o ../../assets/bundle_generated.go ../../img/mine.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag-success.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag-assisted.png

package app

import (
        "image/color"
        "sync"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/assets"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var (
        TileBackgroundColor = color.Gray16{^uint16(0)}
        TileExplodedColor   = color.RGBA{240, 10, 20, alpha}

        TileSize             = fyne.NewSize(32, 32)
        TileTextSize float32 = 23 // Biggest we can go with TileSize of 32^2
)

const alpha = ^uint8(0)

type HelpMarking int

const (
        HelpMarkingNone HelpMarking = iota
        HelpMarkingMine
        HelpMarkingSafe
)

var (
        HelperMarkerSymbols = []string{"", "!", "?"}
        HelperMarkerColors  = []color.Color{
                color.White,
                color.RGBA{180, 15, 15, alpha}, // Mine, red
                color.RGBA{15, 180, 15, alpha}, // Safe, green
        }
)

var TileTextColor = []color.Color{
        color.White,
        color.RGBA{20, 15, 220, alpha},  // 1, blue
        color.RGBA{5, 110, 20, alpha},   // 2, green
        color.RGBA{240, 10, 20, alpha},  // 3, red
        color.RGBA{5, 5, 100, alpha},    // 4, dark blue
        color.RGBA{90, 38, 42, alpha},   // 5, brown
        color.RGBA{25, 230, 230, alpha}, // 6, cyan
        color.RGBA{10, 10, 10, alpha},   // 7, black
        color.RGBA{64, 64, 64, alpha},   // 8, grey
}

// A tile extends the base widget and displays the current state of the backing games field
type Tile struct {
        widget.BaseWidget

        background *canvas.Rectangle
        label      *canvas.Text
        icon       *widget.Icon

        pos  minesweeper.Pos
        grid *MinesweeperGrid

        lFlag   sync.Mutex
        lUpdate sync.Mutex

        field   minesweeper.Field
        flagged bool
        marking HelpMarking
}

// Create a new Tile with a reference to it's parent grid, as well as knowledge of it's own position in the Grid
func NewTile(x, y int, grid *MinesweeperGrid) *Tile <span class="cov9" title="10205">{
        t := &amp;Tile{
                pos: minesweeper.NewPos(x, y),
                field: minesweeper.Field{
                        Checked: false,
                        Content: minesweeper.Unknown,
                },
                grid: grid,
        }
        t.ExtendBaseWidget(t)

        return t
}</span>

// Function to create renderer needed to implement widget
func (t *Tile) CreateRenderer() fyne.WidgetRenderer <span class="cov8" title="9481">{
        t.ExtendBaseWidget(t)

        t.background = canvas.NewRectangle(theme.Color(colorNameTileDefault))
        t.background.SetMinSize(TileSize)

        t.label = canvas.NewText("", color.White)
        t.label.TextStyle.Bold = true
        t.label.Alignment = fyne.TextAlignCenter
        t.label.TextSize = TileTextSize
        t.label.Hidden = true

        t.icon = widget.NewIcon(nil)
        t.icon.Resize(TileSize)
        t.icon.Hidden = true

        content := container.NewStack(t.background, t.icon, t.label)
        return widget.NewSimpleRenderer(content)
}</span>

// Left mouse click on tile
func (t *Tile) Tapped(_ *fyne.PointEvent) <span class="cov2" title="4">{
        if t.untappable() || t.Flagged() </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov1" title="3">go t.grid.TappedTile(t.pos)</span>
}

// Right mouse click on tile
func (t *Tile) TappedSecondary(_ *fyne.PointEvent) <span class="cov2" title="5">{
        if t.untappable() </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="4">if t.Flagged() &amp;&amp; t.Marking() == HelpMarkingMine </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="3">go t.Flag(!t.Flagged())</span>
}

// Double click on tile
func (t *Tile) DoubleTapped(_ *fyne.PointEvent) <span class="cov1" title="3">{
        if !t.Checked() || t.gameFinished() </span><span class="cov1" title="2">{
                return
        }</span>

        <span class="cov1" title="1">go t.grid.TapNeighbours(t.pos)</span>
}

// Update the tile render depending on the current state of it's backing Field.
// Calls to this function should wrap it in fyne.Do
func (t *Tile) Refresh() <span class="cov9" title="12753">{
        t.lUpdate.Lock()
        defer t.lUpdate.Unlock()

        defer canvas.Refresh(t)

        t.icon.Hidden = true
        t.label.Hidden = true
        t.background.FillColor = theme.Color(colorNameTileDefault)

        switch </span>{
        case t.Flagged() &amp;&amp; !t.Checked():<span class="cov5" title="168">
                switch </span>{
                case t.Content() == minesweeper.Mine &amp;&amp; t.Marking() != HelpMarkingMine:<span class="cov1" title="2">
                        t.icon.SetResource(assets.ResourceFlagSuccessPng)</span>
                case t.Marking() == HelpMarkingMine:<span class="cov5" title="156">
                        t.icon.SetResource(assets.ResourceFlagAssistedPng)</span>
                default:<span class="cov3" title="10">
                        t.icon.SetResource(assets.ResourceFlagPng)</span>
                }
                <span class="cov5" title="168">t.icon.Hidden = false</span>
        case t.Marking() != HelpMarkingNone &amp;&amp; !t.Flagged() &amp;&amp; !t.Checked() &amp;&amp; t.Content() == minesweeper.Unknown:<span class="cov6" title="398">
                t.label.Text = HelperMarkerSymbols[t.Marking()]
                t.label.Color = HelperMarkerColors[t.Marking()]
                t.label.Hidden = false</span>
        case t.Content() == minesweeper.Mine:<span class="cov8" title="5188">
                t.icon.SetResource(assets.ResourceMinePng)
                t.icon.Hidden = false
                if t.Checked() </span><span class="cov8" title="5131">{
                        t.background.FillColor = TileExplodedColor
                }</span>
        case t.Checked() &amp;&amp; t.Content() &gt; 0 &amp;&amp; t.Content() &lt; 9:<span class="cov6" title="705">
                t.label.Text = t.Content().String()
                t.label.Color = TileTextColor[t.Content()]
                t.label.Hidden = false
                t.background.FillColor = TileBackgroundColor</span>
        case t.Checked():<span class="cov6" title="524">
                t.background.FillColor = TileBackgroundColor</span>
        }
}

// Reset tile to default state, used for starting new game
func (t *Tile) Reset() <span class="cov7" title="1210">{
        t.flagged = false
        t.field.Checked = false
        t.field.Content = minesweeper.Unknown
        t.marking = HelpMarkingNone
        fyne.Do(t.Refresh)
}</span>

// Returns if the tiles field is checked
func (t *Tile) Checked() bool <span class="cov9" title="27803">{
        return t.field.Checked
}</span>

// Returns the field content
func (t *Tile) Content() minesweeper.FieldContent <span class="cov9" title="16116">{
        return t.field.Content
}</span>

// Set the content of the field
func (t *Tile) SetField(f minesweeper.Field) <span class="cov10" title="30317">{
        if f == t.field </span><span class="cov9" title="23619">{
                return
        }</span>
        <span class="cov8" title="6698">t.field = f
        fyne.Do(t.Refresh)</span>
}

// Returns if the tile is flagged as a suspected mine
func (t *Tile) Flagged() bool <span class="cov9" title="15927">{
        t.lFlag.Lock()
        defer t.lFlag.Unlock()

        return t.flagged
}</span>

// Flag the tile as a suspected mine
func (t *Tile) Flag(v bool) <span class="cov6" title="501">{
        t.lFlag.Lock()
        if v == t.flagged </span><span class="cov6" title="378">{
                t.lFlag.Unlock()
                return
        }</span>

        <span class="cov5" title="123">if t.flagged </span><span class="cov2" title="6">{
                t.grid.MineCount.Inc()
        }</span> else<span class="cov5" title="117"> {
                t.grid.MineCount.Dec()
        }</span>
        <span class="cov5" title="123">t.flagged = v

        t.lFlag.Unlock()
        fyne.Do(t.Refresh)</span>
}

// Returns the marking of the tile
func (t *Tile) Marking() HelpMarking <span class="cov9" title="22030">{
        return t.marking
}</span>

// Mark the tile
func (t *Tile) Mark(m HelpMarking) <span class="cov8" title="6441">{
        if m == t.Marking() </span><span class="cov8" title="6041">{
                return
        }</span>
        <span class="cov6" title="400">t.marking = m
        fyne.Do(t.Refresh)</span>
}

// Check if the tile should be clickable
func (t *Tile) untappable() bool <span class="cov3" title="22">{
        return t.Checked() || t.gameFinished()
}</span>

// Check if game is finished
func (t *Tile) gameFinished() bool <span class="cov3" title="20">{
        if t.grid.Game != nil </span><span class="cov3" title="12">{
                return t.grid.Game.Lost() || t.grid.Game.Won()
        }</span>
        <span class="cov2" title="8">return false</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package app

import (
        "fmt"
        "log/slog"
        "sync"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
)

// Timer to display an upwards countdown in a fyne app.
type Timer struct {
        Label      *canvas.Text
        Seconds    int
        stopSignal chan bool
        running    bool
        lock       sync.Mutex
}

// Create new timer
func NewTimer() *Timer <span class="cov5" title="55">{
        return &amp;Timer{
                Label:      newGridLabel("0000"),
                Seconds:    0,
                stopSignal: make(chan bool),
        }
}</span>

// Start the timer, runs concurrently
func (t *Timer) Start() <span class="cov5" title="27">{
        t.lock.Lock()
        defer t.lock.Unlock()

        if t.running </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov4" title="26">ticker := time.NewTicker(time.Second)
        t.running = true
        go func() </span><span class="cov4" title="26">{
                slog.Debug("Started timer")
                for </span><span class="cov10" title="1643">{
                        select </span>{
                        case &lt;-t.stopSignal:<span class="cov4" title="17">
                                ticker.Stop()
                                return</span>
                        case &lt;-ticker.C:<span class="cov9" title="1617">
                                t.Seconds++
                                t.refresh()</span>
                        }
                }
        }()
}

// Stop the timer
func (t *Timer) Stop() <span class="cov3" title="8">{
        t.lock.Lock()
        defer t.lock.Unlock()

        t.stop()
}</span>

// Reset the timer back to zero
func (t *Timer) Reset() <span class="cov3" title="11">{
        t.lock.Lock()
        defer t.lock.Unlock()

        t.stop()
        t.Seconds = 0
        t.refresh()
}</span>

// Actual stop logic, put here so lock can be aquired first by caller
func (t *Timer) stop() <span class="cov4" title="19">{
        if t.Running() </span><span class="cov4" title="17">{
                t.stopSignal &lt;- true
                t.running = false
                slog.Info("Stopped timer", slog.Int("seconds", t.Seconds))
        }</span>
}

// Check if the timer is running
func (t *Timer) Running() bool <span class="cov7" title="260">{
        return t.running
}</span>

// Refresh the timer from it's current values
func (t *Timer) refresh() <span class="cov9" title="1628">{
        t.Label.Text = fmt.Sprintf("%04d", t.Seconds)
        fyne.Do(t.Label.Refresh)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "os"
        "path/filepath"
        "runtime"
        "runtime/debug"
        "strings"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/widget"
)

// Struct for containing the current version of the app
type Version struct {
        Name, Version, Commit, Go string
}

// Extract the version information from app
func getVersion(app fyne.App) Version <span class="cov4" title="5">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov8" title="60">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov4" title="5">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span>

        <span class="cov4" title="5">metadata := app.Metadata()

        name, _ := strings.CutSuffix(metadata.Name, ".exe")
        if name == "" </span><span class="cov4" title="5">{
                name = filepath.Base(os.Args[0])
        }</span>

        <span class="cov4" title="5">return Version{
                Name:    name,
                Version: "v" + metadata.Version,
                Commit:  commit,
                Go:      runtime.Version(),
        }</span>
}

// Create the content for the version dialog
func getVersionContent(v Version) fyne.CanvasObject <span class="cov0" title="0">{
        data := [][]string{
                {"Version:", v.Version},
                {"Commit:", v.Commit},
                {"Go:", v.Go},
        }

        versionTable := widget.NewTable(
                func() (int, int) </span><span class="cov0" title="0">{
                        return len(data), len(data[0])
                }</span>,
                func() fyne.CanvasObject <span class="cov0" title="0">{
                        return widget.NewLabel("                ")
                }</span>,
                func(i widget.TableCellID, o fyne.CanvasObject) <span class="cov0" title="0">{
                        o.(*widget.Label).SetText(data[i.Row][i.Col])
                }</span>,
        )

        <span class="cov0" title="0">versionTable.ShowHeaderRow = false
        versionTable.ShowHeaderColumn = false
        versionTable.StickyRowCount = len(data) - 1
        versionTable.StickyColumnCount = len(data[0]) - 1
        versionTable.HideSeparators = true

        return versionTable</span>
}

// Wrap the objects in a box with border lines
func newBorder(content ...fyne.CanvasObject) fyne.CanvasObject <span class="cov8" title="44">{
        contentContainer := container.NewThemeOverride(container.NewPadded(content...), mainTheme{})
        border := widget.NewCard("", "", contentContainer)

        return container.NewThemeOverride(border, borderTheme{})
}</span>

// Create a new label used in the grid, with preset color, text size and text style
func newGridLabel(text string) *canvas.Text <span class="cov10" title="109">{
        label := canvas.NewText(text, GridLabelColor)
        label.TextSize = GridLabelSize
        label.TextStyle.Bold = true
        return label
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package minesweeper

const (
        DifficultyClassic      = iota
        DifficultyBeginner     = iota
        DifficultyIntermediate = iota
        DifficultyExpert       = iota
)

const (
        DifficultyRowColMin         = 8
        DifficultyRowColMax         = 99
        DifficultyMineMin           = 9
        DifficultyMineMaxPercentage = 0.8
)

// Represent a difficulty setting for the Game
type Difficulty struct {
        Name     string
        Row, Col int
        Mines    int
}

// Pre-defined difficulties
var difficulties []Difficulty = []Difficulty{
        {
                Name:  "Classic",
                Row:   8,
                Col:   8,
                Mines: 9,
        },
        {
                Name:  "Beginner",
                Row:   9,
                Col:   9,
                Mines: 10,
        },
        {
                Name:  "Intermediate",
                Row:   16,
                Col:   16,
                Mines: 40,
        },
        {
                Name:  "Expert",
                Row:   16,
                Col:   30,
                Mines: 99,
        },
}

// Exposes pre-defined difficulties in a way that does not allow the original array to be modified
func Difficulties() []Difficulty <span class="cov10" title="63">{
        list := make([]Difficulty, len(difficulties))
        copy(list, difficulties)
        return list
}</span>

func NewCustomDifficulty(mines, row, col int) (Difficulty, error) <span class="cov6" title="13">{
        if row &lt; DifficultyRowColMin || row &gt; DifficultyRowColMax || col &lt; DifficultyRowColMin || col &gt; DifficultyRowColMax </span><span class="cov4" title="4">{
                return Difficulty{}, NewErrDifficultyDimension(row, col)
        }</span>
        <span class="cov5" title="9">if mines &lt; DifficultyMineMin || float64(mines) &gt; float64(row*col)*DifficultyMineMaxPercentage </span><span class="cov2" title="2">{
                return Difficulty{}, NewErrDifficultyMineCount(mines)
        }</span>
        <span class="cov5" title="7">return Difficulty{
                Name:  "Custom",
                Row:   row,
                Col:   col,
                Mines: mines,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package minesweeper

import "fmt"

type ErrDifficultyDimension struct {
        row int
        col int
}

func NewErrDifficultyDimension(row, col int) error <span class="cov10" title="8">{
        return &amp;ErrDifficultyDimension{row, col}
}</span>

func (e *ErrDifficultyDimension) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Rows and Columns need to be between %d and %d, got %dx%d", DifficultyRowColMin, DifficultyRowColMax, e.row, e.col)
}</span>

type ErrDifficultyMineCount struct {
        mines int
}

func NewErrDifficultyMineCount(mines int) error <span class="cov7" title="4">{
        return &amp;ErrDifficultyMineCount{mines}
}</span>

func (e *ErrDifficultyMineCount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("The number of mines need to be between %d and %.1f %% of the total number of cells, got %d", DifficultyMineMin, DifficultyMineMaxPercentage*100, e.mines)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package minesweeper

import (
        "log/slog"

        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

// Represents the content of a field.
// Can be a mine, unknown or the number of mines in the neighboring fields
type FieldContent int

const (
        Mine    FieldContent = -1
        Unknown FieldContent = -2
)

// Represents a single field in a minefield
type Field struct {
        Checked bool
        Content FieldContent
}

// Interface for playing the game
type Game interface {
        // Check a given field and recursevly reveal all neighboring fields that should be revield.
        // Returns the resulting new status of the game
        CheckField(p Pos) (*Status, bool)
        // Check if the given position is out of bounds
        OutOfBounds(p Pos) bool
        // Returns the current status of the game. Only contains the knowledge a player should have.
        Status() *Status
        // Check if Game Over
        Lost() bool
        // Check if the game is won
        Won() bool
        // Reset the current game to be played again
        Replay()
        // Check if the game is a replay
        IsReplay() bool
        // Generate a save from the game
        ToSave() (*Save, error)
}

// Ensure that compiler throws error if LocalGame does not implement Game interface
var _ = Game(&amp;LocalGame{})

type LocalGame struct {
        Field      [][]Field
        Difficulty Difficulty

        // Keep these 2 exported for testing in other packages
        GameOver bool
        GameWon  bool

        // Cache the last status
        status *Status

        replay bool
}

// Utility function to create empty game
func blankGame(d Difficulty) *LocalGame <span class="cov5" title="3772">{
        return &amp;LocalGame{
                Field:      utils.Make2D[Field](d.Row, d.Col),
                Difficulty: d,
                GameOver:   false,
                GameWon:    false,
        }
}</span>

// Create a new game with the mines in the given positions
func newGame(d Difficulty, mines []Pos) *LocalGame <span class="cov5" title="3750">{
        g := blankGame(d)

        for _, mine := range mines </span><span class="cov7" title="368275">{
                g.Field[mine.X][mine.Y].Content = Mine
        }</span>

        <span class="cov5" title="3750">g.calculateFieldContent()

        return g</span>
}

// Create a new game with mines seeded randomly in the map, with the exception of the given position.
func NewGameWithSafePos(d Difficulty, p Pos) *LocalGame <span class="cov2" title="37">{
        mines := CreateMines(d, []Pos{p})

        return newGame(d, mines)
}</span>

// Create a new game with mines seeded randomly in the map, with the exception of a 3x3 area around the given position.
func NewGameWithSafeArea(d Difficulty, p Pos) *LocalGame <span class="cov2" title="18">{
        mines := CreateMines(d, areaAroundPos(d, p))

        return newGame(d, mines)
}</span>

// Create a new game that is solvable without random guesses.
func NewGameSolvable(d Difficulty, p Pos) *LocalGame <span class="cov1" title="6">{
        area := areaAroundPos(d, p)

        var mines []Pos
        var success bool
        for i := 0; i &lt; 10000; i++ </span><span class="cov5" title="3689">{
                mines = CreateMines(d, area)
                g := newGame(d, mines)

                if success = autosolve(g, p); success </span><span class="cov1" title="6">{
                        break</span>
                }
        }
        <span class="cov1" title="6">if success </span><span class="cov1" title="6">{
                slog.Info("Created solvable minesweeper game")
        }</span> else<span class="cov0" title="0"> {
                slog.Error("Failed to create a solvable minesweeper game")
        }</span>

        <span class="cov1" title="6">return newGame(d, mines)</span>
}

// Check a given field and recursevly reveal all neighboring fields that should be revield.
// Returns the resulting new status of the game and a boolean indicating if there where changes.
func (g *LocalGame) CheckField(p Pos) (*Status, bool) <span class="cov6" title="121752">{
        if g.Lost() || g.Won() || g.Field[p.X][p.Y].Checked </span><span class="cov5" title="10120">{
                return g.Status(), false
        }</span>

        <span class="cov6" title="111632">g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content == Mine </span><span class="cov1" title="2">{
                g.GameOver = true
                return g.UpdateStatus(), true
        }</span>

        <span class="cov6" title="111630">g.revealField(p)

        return g.UpdateStatus(), true</span>
}

// Recursive function to reveal all neighbouring fields that can be safely reveald.
// Stops when a field has not exactly zero neighbouring mines
func (g *LocalGame) revealField(p Pos) <span class="cov7" title="280805">{
        slog.Debug("Reveal field", slog.String("pos", p.String()), slog.String("content", g.Field[p.X][p.Y].Content.String()))

        g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content != 0 </span><span class="cov7" title="202184">{
                return
        }</span>

        <span class="cov6" title="78621">slog.Debug("Revealing fields neigbhours", slog.String("pos", p.String()))

        for m := -1; m &lt; 2; m++ </span><span class="cov7" title="235863">{
                for n := -1; n &lt; 2; n++ </span><span class="cov7" title="707589">{
                        if m == 0 &amp;&amp; n == 0 </span><span class="cov6" title="78621">{
                                continue</span>
                        }
                        <span class="cov7" title="628968">i := NewPos(p.X+m, p.Y+n)
                        if g.OutOfBounds(i) </span><span class="cov6" title="104743">{
                                continue</span>
                        }
                        <span class="cov7" title="524225">if !g.Field[i.X][i.Y].Checked </span><span class="cov7" title="169175">{
                                g.revealField(i)
                        }</span>
                }
        }
}

// Check if the given position is out of bounds
func (g *LocalGame) OutOfBounds(p Pos) bool <span class="cov9" title="13427929">{
        if g == nil </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov9" title="13427928">return OutOfBounds(p, g.Difficulty)</span>
}

// Returns the current status of the game. Only contains the knowledge a player should have.
func (g *LocalGame) Status() *Status <span class="cov6" title="30033">{
        return g.status
}</span>

// Update the status from the current state of the game.
// Returns status for convenience.
func (g *LocalGame) UpdateStatus() *Status <span class="cov6" title="111651">{
        if g.status == nil </span><span class="cov5" title="3753">{
                g.status = &amp;Status{
                        Field:      utils.Make2D[Field](g.Difficulty.Row, g.Difficulty.Col),
                        gameOver:   g.Lost(),
                        gameWon:    g.Won(),
                        difficulty: g.Difficulty,
                }
        }</span>
        <span class="cov6" title="111651">g.status.actionsUpdated = false

        wasWon := g.Won()
        isWon := true

        g.walkField(func(x, y int) </span><span class="cov10" title="53316077">{
                g.status.Field[x][y].Checked = g.Field[x][y].Checked
                if g.Field[x][y].Checked || g.Lost() || g.Won() </span><span class="cov9" title="14560915">{
                        g.status.Field[x][y].Content = g.Field[x][y].Content
                }</span> else<span class="cov9" title="38755162"> {
                        g.status.Field[x][y].Content = Unknown
                }</span>
                <span class="cov10" title="53316077">if !g.Field[x][y].Checked &amp;&amp; g.Field[x][y].Content != Mine </span><span class="cov9" title="27771866">{
                        isWon = false
                }</span>
        })

        <span class="cov6" title="111651">if !wasWon &amp;&amp; isWon </span><span class="cov2" title="20">{
                g.GameWon = isWon
                for x := 0; x &lt; g.Difficulty.Row; x++ </span><span class="cov3" title="291">{
                        copy(g.status.Field[x], g.Field[x])
                }</span>
        }

        <span class="cov6" title="111651">g.status.gameOver = g.GameOver
        g.status.gameWon = g.GameWon

        return g.status</span>
}

// Check if Game Over
func (g *LocalGame) Lost() bool <span class="cov9" title="38882211">{
        return g.GameOver
}</span>

// Check if the game is won
func (g *LocalGame) Won() bool <span class="cov9" title="39012842">{
        return g.GameWon
}</span>

// Reset the current game to be played again
func (g *LocalGame) Replay() <span class="cov1" title="4">{
        g.replay = true
        g.GameOver = false
        g.GameWon = false
        g.status = nil

        g.walkField(func(x, y int) </span><span class="cov3" title="324">{
                g.Field[x][y].Checked = false
        }</span>)
}

// Check if the game is a replay
func (g *LocalGame) IsReplay() bool <span class="cov1" title="4">{
        return g.replay
}</span>

// Generate a save from the game
func (g *LocalGame) ToSave() (*Save, error) <span class="cov1" title="1">{
        g.replay = true
        return NewSave(g)
}</span>

// Walk through all fields of the game and call the given function
func (g *LocalGame) walkField(f func(x, y int)) <span class="cov6" title="115461">{
        walkField(f, g.Difficulty.Row, g.Difficulty.Col)
}</span>

// Count the the number of mines in the neighboring fields
func (g *LocalGame) countNearbyMines(p Pos) int <span class="cov8" title="1421837">{
        c := 0
        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="4265511">{
                for n := -1; n &lt; 2; n++ </span><span class="cov9" title="12796533">{
                        if g.OutOfBounds(NewPos(p.X+m, p.Y+n)) </span><span class="cov7" title="818043">{
                                continue</span>
                        }
                        <span class="cov9" title="11978490">if g.Field[p.X+m][p.Y+n].Content == Mine </span><span class="cov8" title="2183273">{
                                c++
                        }</span>
                }
        }
        <span class="cov8" title="1421837">return c</span>
}

// Get a list of all mines in the game
func (g *LocalGame) getMines() []Pos <span class="cov1" title="1">{
        mines := make([]Pos, 0, g.Difficulty.Mines)

        g.walkField(func(x, y int) </span><span class="cov3" title="256">{
                if g.Field[x][y].Content == Mine </span><span class="cov2" title="40">{
                        mines = append(mines, NewPos(x, y))
                }</span>
        })
        <span class="cov1" title="1">return mines</span>
}

// Calculate all fields with the count of neighbouring mines
func (g *LocalGame) calculateFieldContent() <span class="cov5" title="3772">{
        g.walkField(func(x, y int) </span><span class="cov8" title="1787933">{
                if g.Field[x][y].Content == Mine </span><span class="cov7" title="369408">{
                        return
                }</span>

                <span class="cov8" title="1418525">g.Field[x][y].Content = FieldContent(g.countNearbyMines(NewPos(x, y)))</span>
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package minesweeper

import (
        "crypto/sha512"
        "encoding/hex"
        "encoding/json"
        "os"
        "path/filepath"
)

const SaveFileExtension = ".sav"

type Save struct {
        // ID is the hash generated from the Data
        ID string `json:"id"`
        // Data contains everything necessary to create a game
        Data saveData `json:"data"`
}

type saveData struct {
        Mines      []Pos      `json:"mines"`
        Difficulty Difficulty `json:"difficulty"`
}

// Create a new save from the given game
func NewSave(game *LocalGame) (*Save, error) <span class="cov1" title="1">{
        data := saveData{
                Mines:      game.getMines(),
                Difficulty: game.Difficulty,
        }

        buf, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">hash := sha512.Sum512(buf)

        return &amp;Save{
                ID:   hex.EncodeToString(hash[:]),
                Data: data,
        }, nil</span>
}

// Load a save file from the given path
func LoadSave(path string) (*Save, error) <span class="cov4" title="22">{
        buf, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="22">var save Save
        err = json.Unmarshal(buf, &amp;save)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="22">return &amp;save, nil</span>
}

// Write save file to the given path.
// Needs to have the correct extension.
func (s *Save) Save(path string) error <span class="cov1" title="2">{
        if filepath.Ext(path) != SaveFileExtension </span><span class="cov1" title="1">{
                path += SaveFileExtension
        }</span>

        <span class="cov1" title="2">data, err := json.MarshalIndent(s, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="2">return os.WriteFile(path, data, 0644)</span>
}

// Creates a LocalGame from the save.
// The game will be considered a replay
func (s *Save) Game() *LocalGame <span class="cov4" title="22">{
        g := blankGame(s.Data.Difficulty)

        for _, p := range s.Data.Mines </span><span class="cov10" title="1133">{
                g.Field[p.X][p.Y].Content = Mine
        }</span>

        <span class="cov4" title="22">g.calculateFieldContent()

        g.replay = true

        return g</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package minesweeper

import (
        "log/slog"
        "slices"
        "sync"
)

// Status contains the current state of the game known to the player.
// As such it will always be a copy and needs to be it's own type, despite the
// overlapping similarities.
// It does not support any of the functions that Game does.
// It is safe to write to Status, as it is merely a copy.
type Status struct {
        Field      [][]Field
        gameOver   bool
        gameWon    bool
        difficulty Difficulty

        actionsUpdated bool
        actions        Actions
        mutex          sync.Mutex

        // Used only for unit-tests
        updateActionsCalled func()
}

type Actions struct {
        Mines   []Pos
        SafePos []Pos
}

// Returns if the game is lost
func (s *Status) GameOver() bool <span class="cov6" title="21136">{
        return s.gameOver
}</span>

// Returns if the game is won
func (s *Status) GameWon() bool <span class="cov6" title="21139">{
        return s.gameWon
}</span>

// Returns the position of all obvious mines
func (s *Status) ObviousMines() []Pos <span class="cov4" title="367">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if !s.actionsUpdated </span><span class="cov3" title="201">{
                s.updateActions()
        }</span>
        <span class="cov4" title="367">return s.actions.Mines</span>
}

// Returns the position of all obvious safe positions
func (s *Status) ObviousSafePos() []Pos <span class="cov6" title="20292">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if !s.actionsUpdated </span><span class="cov6" title="20005">{
                s.updateActions()
        }</span>
        <span class="cov6" title="20292">return s.actions.SafePos</span>
}

// Calculate the next actions based on the current status
func (s *Status) updateActions() <span class="cov6" title="20210">{
        if s.updateActionsCalled != nil </span><span class="cov1" title="1">{
                s.updateActionsCalled()
        }</span>

        <span class="cov6" title="20210">s.actionsUpdated = true
        if len(s.Field) == 0 || s.GameOver() || s.GameWon() </span><span class="cov2" title="22">{
                return
        }</span>
        <span class="cov6" title="20188">if s.actions.Mines == nil </span><span class="cov5" title="3715">{
                s.actions.Mines = make([]Pos, 0, s.difficulty.Mines)
        }</span>
        <span class="cov6" title="20188">safePos := make([]Pos, 0, 25)
        for _, p := range s.actions.SafePos </span><span class="cov7" title="120663">{
                if !s.Field[p.X][p.Y].Checked </span><span class="cov5" title="2634">{
                        safePos = append(safePos, p)
                }</span>
        }
        <span class="cov6" title="20188">s.actions.SafePos = safePos

        i := 0
        oldLenMines := -1
        oldLenSafe := -1
        for len(s.actions.Mines) &gt; oldLenMines || len(s.actions.SafePos) &gt; oldLenSafe </span><span class="cov6" title="53682">{
                i++
                oldLenMines = len(s.actions.Mines)
                oldLenSafe = len(s.actions.SafePos)
                walkField(func(x, y int) </span><span class="cov9" title="25524469">{
                        if !s.Field[x][y].Checked || s.Field[x][y].Content &lt;= 0 </span><span class="cov9" title="21104515">{
                                return
                        }</span>

                        <span class="cov8" title="4419954">unchecked := FieldContent(0)
                        mines := FieldContent(0)
                        safePos := FieldContent(0)
                        newPos := make([]Pos, 0, 8)
                        for m := -1; m &lt; 2; m++ </span><span class="cov9" title="13259862">{
                                for n := -1; n &lt; 2; n++ </span><span class="cov10" title="39779586">{
                                        p := NewPos(x+m, y+n)
                                        if OutOfBounds(p, s.difficulty) </span><span class="cov8" title="1408453">{
                                                continue</span>
                                        }
                                        <span class="cov9" title="38371133">if !s.Field[p.X][p.Y].Checked </span><span class="cov9" title="9384502">{
                                                unchecked++
                                                if slices.Contains(s.actions.Mines, p) </span><span class="cov9" title="6932099">{
                                                        mines++
                                                }</span> else<span class="cov8" title="2452403"> if !slices.Contains(s.actions.SafePos, p) </span><span class="cov8" title="1793429">{
                                                        newPos = append(newPos, p)
                                                }</span> else<span class="cov7" title="658974"> {
                                                        safePos++
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="4419954">if len(newPos) == 0 </span><span class="cov8" title="3734559">{
                                return
                        }</span>
                        <span class="cov7" title="685395">if unchecked-safePos == s.Field[x][y].Content &amp;&amp; mines != s.Field[x][y].Content </span><span class="cov6" title="47458">{
                                slog.Debug("Assisted Mode: Found mines near field",
                                        slog.String("pos", NewPos(x, y).String()),
                                        slog.Int("mines", int(mines)),
                                        slog.Int("unchecked", int(unchecked)),
                                        slog.Int("content", int(s.Field[x][y].Content)),
                                        slog.Any("newPos", newPos),
                                )
                                s.actions.Mines = append(s.actions.Mines, newPos...)
                        }</span> else<span class="cov7" title="637937"> if mines == s.Field[x][y].Content &amp;&amp; unchecked &gt; s.Field[x][y].Content </span><span class="cov6" title="74454">{
                                slog.Debug("Assisted Mode: Found safe positions near field",
                                        slog.String("pos", NewPos(x, y).String()),
                                        slog.Int("mines", int(mines)),
                                        slog.Int("unchecked", int(unchecked)),
                                        slog.Int("content", int(s.Field[x][y].Content)),
                                        slog.Any("newPos", newPos),
                                )
                                s.actions.SafePos = append(s.actions.SafePos, newPos...)
                        }</span>
                }, s.difficulty.Row, s.difficulty.Col)
        }

        <span class="cov6" title="20188">slog.Debug("Assisted Mode: Mines and safe Positions found", slog.Any("mines", s.actions.Mines), slog.Any("safe", s.actions.SafePos), slog.Int("iterations", i))</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package minesweeper

import (
        "fmt"
        "math/rand/v2"
        "slices"
        "strconv"
)

// Represent a position in the minefield
type Pos struct {
        X, Y int
}

// Create a new Position from the given coordinates
func NewPos(x, y int) Pos <span class="cov9" title="55184475">{
        return Pos{x, y}
}</span>

// Returns a random position inside the provided limits
func RandomPos(maxX, maxY int) Pos <span class="cov7" title="422155">{
        return NewPos(rand.IntN(maxX), rand.IntN(maxY))
}</span>

// Returns a string representation of the position
func (p Pos) String() string <span class="cov7" title="486313">{
        return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}</span>

// Randomly create mines for the given difficulty.
// Does not create a mine on the given positions.
func CreateMines(d Difficulty, safe []Pos) []Pos <span class="cov5" title="3749">{
        var p Pos
        mines := make([]Pos, 0, d.Mines+len(safe))

        mines = append(mines, safe...)
        for i := 0; i &lt; d.Mines; i++ </span><span class="cov7" title="369166">{
                p = RandomPos(d.Row, d.Col)
                for slices.Contains(mines, p) </span><span class="cov6" title="52984">{
                        p = RandomPos(d.Row, d.Col)
                }</span>
                <span class="cov7" title="369166">mines = append(mines, p)</span>
        }
        <span class="cov5" title="3749">return mines[len(safe):]</span>
}

// Convert FieldContent to string for logging
func (fc FieldContent) String() string <span class="cov7" title="281523">{
        switch </span>{
        case fc == Mine:<span class="cov1" title="1">
                return "Mine"</span>
        case fc == Unknown:<span class="cov1" title="1">
                return "Unknown"</span>
        case fc &gt;= 0 &amp;&amp; fc &lt; 9:<span class="cov7" title="281519">
                return strconv.Itoa(int(fc))</span>
        default:<span class="cov1" title="2">
                return fmt.Sprintf("%d is not a valid FieldContent", fc)</span>
        }
}

// Check if a position is out of bounds on the given difficulty
func OutOfBounds(p Pos, d Difficulty) bool <span class="cov9" title="53207730">{
        return p.X &lt; 0 || p.X &gt; d.Row-1 || p.Y &lt; 0 || p.Y &gt; d.Col-1
}</span>

// Walk through all fields in the given dimension and call the given function
func walkField(f func(x, y int), limitX, limitY int) <span class="cov6" title="169143">{
        for x := 0; x &lt; limitX; x++ </span><span class="cov8" title="3918843">{
                for y := 0; y &lt; limitY; y++ </span><span class="cov10" title="80636455">{
                        f(x, y)
                }</span>
        }
}

// Autosolve the given Game
// Returns if the game can be autosolved
func autosolve(g *LocalGame, startPos Pos) bool <span class="cov5" title="3704">{
        g.CheckField(startPos)

        for safePos := g.Status().ObviousSafePos(); len(safePos) &gt; 0 &amp;&amp; !g.Won(); safePos = g.Status().ObviousSafePos() </span><span class="cov5" title="16177">{
                for _, p := range safePos </span><span class="cov6" title="117744">{
                        g.CheckField(p)
                }</span>
        }

        <span class="cov5" title="3704">return g.Won()</span>
}

// Create an array of positions with 3x3, centered around the given position
func areaAroundPos(d Difficulty, p Pos) []Pos <span class="cov2" title="24">{
        area := make([]Pos, 0, 9)
        for x := -1; x &lt; 2; x++ </span><span class="cov3" title="72">{
                for y := -1; y &lt; 2; y++ </span><span class="cov3" title="216">{
                        p := NewPos(p.X+x, p.Y+y)
                        if !OutOfBounds(p, d) </span><span class="cov3" title="151">{
                                area = append(area, p)
                        }</span>
                }
        }
        <span class="cov2" title="24">return area</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package utils

// Create a new, empty 2 dimensional array of the given type and dimensions.
func Make2D[T any](x, y int) [][]T <span class="cov7" title="7588">{
        if x &lt; 1 || y &lt; 1 </span><span class="cov2" title="6">{
                return [][]T{}
        }</span>

        <span class="cov7" title="7582">matrix := make([][]T, x)
        rows := make([]T, x*y)

        for i := 0; i &lt; x; i++ </span><span class="cov10" title="175284">{
                matrix[i] = rows[i*y : (i+1)*y]
        }</span>
        <span class="cov7" title="7582">return matrix</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
