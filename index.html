
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/go-minesweeper/pkg/app/app.go (62.7%)</option>
				
				<option value="file1">github.com/heathcliff26/go-minesweeper/pkg/app/button.go (100.0%)</option>
				
				<option value="file2">github.com/heathcliff26/go-minesweeper/pkg/app/counter.go (100.0%)</option>
				
				<option value="file3">github.com/heathcliff26/go-minesweeper/pkg/app/grid.go (99.1%)</option>
				
				<option value="file4">github.com/heathcliff26/go-minesweeper/pkg/app/locations/locations.go (63.2%)</option>
				
				<option value="file5">github.com/heathcliff26/go-minesweeper/pkg/app/locations/locations_linux.go (85.7%)</option>
				
				<option value="file6">github.com/heathcliff26/go-minesweeper/pkg/app/preferences.go (92.1%)</option>
				
				<option value="file7">github.com/heathcliff26/go-minesweeper/pkg/app/theme.go (100.0%)</option>
				
				<option value="file8">github.com/heathcliff26/go-minesweeper/pkg/app/tile.go (100.0%)</option>
				
				<option value="file9">github.com/heathcliff26/go-minesweeper/pkg/app/timer.go (100.0%)</option>
				
				<option value="file10">github.com/heathcliff26/go-minesweeper/pkg/app/utils.go (62.9%)</option>
				
				<option value="file11">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/difficulty.go (100.0%)</option>
				
				<option value="file12">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/errors.go (50.0%)</option>
				
				<option value="file13">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/game.go (99.0%)</option>
				
				<option value="file14">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/save.go (84.6%)</option>
				
				<option value="file15">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/solver.go (100.0%)</option>
				
				<option value="file16">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/status.go (100.0%)</option>
				
				<option value="file17">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/utils.go (100.0%)</option>
				
				<option value="file18">github.com/heathcliff26/go-minesweeper/pkg/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "log/slog"
        "os"
        "time"

        "fyne.io/fyne/v2"
        fApp "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/data/binding"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/pkg/app/locations"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "github.com/heathcliff26/godialog"
        fallbackfyne "github.com/heathcliff26/godialog/fallback/fyne"
)

const DEFAULT_DIFFICULTY = minesweeper.DifficultyBeginner

const DEFAULT_GAME_ALGORITHM = GameAlgorithmSafeArea

const DEFAULT_AUTOSOLVE_DELAY = 500 * time.Millisecond

// Used to change the new app function for testing
var newApp = fApp.New

var saveFileFilters = godialog.FileFilters{
        {
                Description: "Save File (*" + minesweeper.SaveFileExtension + ")",
                Extensions:  []string{minesweeper.SaveFileExtension},
        },
}

// Struct representing the current app.
// There should only ever be a single instance during runtime.
type App struct {
        app            fyne.App
        main           fyne.Window
        Version        Version
        grid           *MinesweeperGrid
        difficulties   []*fyne.MenuItem
        gameMenu       []*fyne.MenuItem
        assistedMode   *fyne.MenuItem
        gameAlgorithms []*fyne.MenuItem
        filedialog     godialog.FileDialog
}

// Create a new App
func New() *App <span class="cov4" title="5">{
        preferences, err := LoadPreferences()
        if err != nil </span><span class="cov4" title="4">{
                slog.Info("Failed to load preferences, falling back to defaults", "err", err)
        }</span> else<span class="cov1" title="1"> {
                slog.Debug("Loaded preferences", "preferences", preferences)
        }</span>

        <span class="cov4" title="5">app := newApp()
        version := getVersion(app)
        main := app.NewWindow(version.Name)
        app.Settings().SetTheme(mainTheme{})

        fd := godialog.NewFileDialog()
        fd.SetFilters(saveFileFilters)
        fd.SetFallback(fallbackfyne.NewFyneFallbackDialog(app))

        a := &amp;App{
                app:        app,
                main:       main,
                Version:    version,
                filedialog: fd,
        }
        a.main.SetTitle(version.Name)
        a.makeMenu(preferences)
        a.NewGrid(preferences.Difficulty())
        a.setGameAlgorithm(preferences.GameAlgorithm)

        a.main.SetFixedSize(true)
        a.main.Show()

        saveDir, err := locations.SaveFolder()
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, main)
        }</span>
        <span class="cov4" title="5">a.filedialog.SetInitialDirectory(saveDir)

        return a</span>
}

// Simply calls app.Run()
func (a *App) Run() <span class="cov0" title="0">{
        a.app.Run()

        preferences := CreatePreferencesFromApp(a)
        err := preferences.Save()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to save preferences for next time", "err", err)
        }</span> else<span class="cov0" title="0"> {
                slog.Info("Saved preferences")
        }</span>
}

// Create the main menu bar
func (a *App) makeMenu(preferences Preferences) <span class="cov4" title="5">{
        // Can't assign grid functions directly, as the instance of grid may change
        newGameOption := fyne.NewMenuItem("New", func() </span><span class="cov2" title="2">{
                a.grid.NewGame()
        }</span>)
        <span class="cov4" title="5">replayOption := fyne.NewMenuItem("Replay", func() </span><span class="cov2" title="2">{
                a.grid.Replay()
        }</span>)
        <span class="cov4" title="5">loadOption := fyne.NewMenuItem("Load", a.loadSave)
        saveOption := fyne.NewMenuItem("Save", a.saveGame)
        a.gameMenu = []*fyne.MenuItem{newGameOption, replayOption, fyne.NewMenuItemSeparator(), loadOption, saveOption}
        gameMenu := fyne.NewMenu("Game", a.gameMenu...)

        difficulties := minesweeper.Difficulties()
        diffItems := make([]*fyne.MenuItem, 0, len(difficulties)+2)
        for _, d := range difficulties </span><span class="cov8" title="20">{
                item := fyne.NewMenuItem(d.Name, nil)
                item.Action = func() </span><span class="cov4" title="4">{
                        if item.Checked </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov4" title="4">for _, i := range a.difficulties </span><span class="cov8" title="24">{
                                i.Checked = (i.Label == d.Name)
                        }</span>
                        <span class="cov4" title="4">a.NewGrid(d)</span>
                }
                <span class="cov8" title="20">item.Checked = (d == preferences.Difficulty())
                diffItems = append(diffItems, item)</span>
        }
        <span class="cov4" title="5">diffItems = append(diffItems, fyne.NewMenuItemSeparator())
        diffItems = append(diffItems, fyne.NewMenuItem("Custom", a.customDifficultyDialog))
        a.difficulties = diffItems
        diffMenu := fyne.NewMenu("Difficulties", diffItems...)

        a.assistedMode = fyne.NewMenuItem("      Assisted Mode", func() </span><span class="cov2" title="2">{
                a.assistedMode.Checked = !a.assistedMode.Checked
                a.grid.AssistedMode = a.assistedMode.Checked
                if a.grid.AssistedMode &amp;&amp; a.grid.Game != nil </span><span class="cov0" title="0">{
                        go a.grid.updateFromStatus(a.grid.Game.Status())
                }</span>
        })
        <span class="cov4" title="5">a.assistedMode.Checked = preferences.AssistedMode
        a.gameAlgorithms = make([]*fyne.MenuItem, 3)
        a.gameAlgorithms[0] = fyne.NewMenuItem("Safe Position", func() </span><span class="cov1" title="1">{
                a.setGameAlgorithm(GameAlgorithmSafePos)
        }</span>)
        <span class="cov4" title="5">a.gameAlgorithms[1] = fyne.NewMenuItem("Safe Area", func() </span><span class="cov1" title="1">{
                a.setGameAlgorithm(GameAlgorithmSafeArea)
        }</span>)
        <span class="cov4" title="5">a.gameAlgorithms[2] = fyne.NewMenuItem("Solvable", func() </span><span class="cov1" title="1">{
                a.setGameAlgorithm(GameAlgorithmSolvable)
        }</span>)
        <span class="cov4" title="5">gameAlgorithmSubMenu := fyne.NewMenuItem("Creation Algorithm", nil)
        gameAlgorithmSubMenu.ChildMenu = fyne.NewMenu("Creation Algorithm", a.gameAlgorithms...)
        autosolve := fyne.NewMenuItem("Autosolve", func() </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        if !a.grid.Autosolve(DEFAULT_AUTOSOLVE_DELAY) </span><span class="cov0" title="0">{
                                fyne.Do(func() </span><span class="cov0" title="0">{
                                        dialog.ShowInformation("Autosolve", "Failed to run autosolve, please ensure that a game is currently running.", a.main)
                                }</span>)
                        }
                }()
        })
        <span class="cov4" title="5">optionsMenu := fyne.NewMenu("Options", a.assistedMode, gameAlgorithmSubMenu, autosolve)

        hint := fyne.NewMenuItem("Hint", func() </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        if !a.grid.Hint() </span><span class="cov0" title="0">{
                                fyne.Do(func() </span><span class="cov0" title="0">{
                                        dialog.NewInformation("No hint found", "Could not find any hints to give.", a.main).Show()
                                }</span>)
                        }
                }()
        })
        <span class="cov4" title="5">about := fyne.NewMenuItem("About", func() </span><span class="cov0" title="0">{
                vInfo := dialog.NewCustom(a.Version.Name, "close", getVersionContent(a.Version), a.main)
                vInfo.Show()
        }</span>)
        <span class="cov4" title="5">helpMenu := fyne.NewMenu("Help", hint, about)

        a.main.SetMainMenu(fyne.NewMainMenu(gameMenu, diffMenu, optionsMenu, helpMenu))</span>
}

// Update the content of the app and resize the window to make it fit
func (a *App) setContent() <span class="cov7" title="14">{
        content := container.NewPadded(a.grid.GetCanvasObject())
        content.Resize(content.MinSize())

        a.main.SetContent(content)
        a.main.Resize(content.MinSize())
}</span>

// Show a dialog for setting a custom difficulty
func (a *App) customDifficultyDialog() <span class="cov0" title="0">{
        mines := minesweeper.DifficultyMineMin
        row, col := minesweeper.DifficultyRowColMin, minesweeper.DifficultyRowColMin

        mineItem := widget.NewFormItem("Mines", widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;mines))))
        rowItem := widget.NewFormItem("Rows", widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;row))))
        colItem := widget.NewFormItem("Columns", widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;col))))

        content := widget.NewForm(mineItem, rowItem, colItem)

        diffDialog := dialog.NewCustomConfirm("Custom Difficulty", "ok", "cancel", content, func(ok bool) </span><span class="cov0" title="0">{
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">d, err := minesweeper.NewCustomDifficulty(mines, row, col)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">for _, i := range a.difficulties </span><span class="cov0" title="0">{
                        i.Checked = (i.Label == "Custom")
                }</span>
                <span class="cov0" title="0">a.NewGrid(d)</span>
        }, a.main)
        <span class="cov0" title="0">diffDialog.Show()</span>
}

func (a *App) loadSave() <span class="cov0" title="0">{
        a.filedialog.Open("Open Savegame", a.loadSaveCallback)
}</span>

func (a *App) loadSaveCallback(path string, err error) <span class="cov1" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>
        <span class="cov1" title="1">if path == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">save, err := minesweeper.LoadSave(path)
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>

        <span class="cov1" title="1">for _, i := range a.difficulties </span><span class="cov5" title="6">{
                i.Checked = (i.Label == save.Data.Difficulty.Name)
        }</span>
        <span class="cov1" title="1">fyne.DoAndWait(func() </span><span class="cov1" title="1">{
                a.NewGrid(save.Data.Difficulty)
        }</span>)

        <span class="cov1" title="1">a.grid.Game = save.Game()</span>
}

func (a *App) saveGame() <span class="cov0" title="0">{
        if a.grid.Game == nil </span><span class="cov0" title="0">{
                d := dialog.NewInformation("Can't save game", "You need to first start a game before you can save it.", a.main)
                d.Show()
                return
        }</span>
        <span class="cov0" title="0">a.filedialog.Save("Save Game", a.saveGameCallback)</span>
}

func (a *App) saveGameCallback(path string, err error) <span class="cov3" title="3">{
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>
        <span class="cov3" title="3">if path == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Ensure that empty files created by fynes file dialog are removed before creating the save.
        // This ensures that no empty files without ".sav" extension are created.
        <span class="cov3" title="3">err = os.Remove(path)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>

        <span class="cov3" title="3">save, err := a.grid.Game.ToSave()
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>

        <span class="cov3" title="3">err = save.Save(path)
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, a.main)
                return
        }</span>
}

func (a *App) NewGrid(d minesweeper.Difficulty) <span class="cov7" title="13">{
        a.grid = NewMinesweeperGrid(d, a.assistedMode.Checked)
        for i, item := range a.gameAlgorithms </span><span class="cov10" title="39">{
                if item.Checked </span><span class="cov6" title="8">{
                        a.grid.GameAlgorithm = i
                }</span>
        }
        <span class="cov7" title="13">a.setContent()</span>
}

func (a *App) setGameAlgorithm(id int) <span class="cov6" title="8">{
        for i, item := range a.gameAlgorithms </span><span class="cov8" title="24">{
                item.Checked = i == id
        }</span>
        <span class="cov6" title="8">a.grid.GameAlgorithm = id</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/widget"
)

// Custom implementation for a button that is only portraied by text.
// The text is fully configurable by exposing the backing label.
type Button struct {
        widget.BaseWidget

        Label  *canvas.Text
        Action func()
}

// Create a new button from the given text, color and function
func NewButton(text string, color color.Color, action func()) *Button <span class="cov10" title="58">{
        b := &amp;Button{
                Label:  canvas.NewText(text, color),
                Action: action,
        }
        b.ExtendBaseWidget(b)
        return b
}</span>

// Function to create renderer needed to implement widget
func (b *Button) CreateRenderer() fyne.WidgetRenderer <span class="cov8" title="25">{
        return widget.NewSimpleRenderer(b.Label)
}</span>

// Left click action
func (b *Button) Tapped(_ *fyne.PointEvent) <span class="cov1" title="1">{
        b.Action()
}</span>

// Right click action, currently not implemented or exposed
func (b *Button) TappedSecondary(_ *fyne.PointEvent) {<span class="cov0" title="0">}</span>

// Set label text to the given string and refresh widget
func (b *Button) SetText(text string) <span class="cov7" title="20">{
        b.Label.Text = text
        fyne.Do(b.Refresh)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "fmt"
        "strconv"
        "sync"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
)

// Displays a counter that can be increased and decreased
type Counter struct {
        Label *canvas.Text
        Count int

        lock sync.Mutex
}

// Create new counter
func NewCounter(count int) *Counter <span class="cov8" title="59">{
        return &amp;Counter{
                Label: newGridLabel(strconv.Itoa(count)),
                Count: count,
        }
}</span>

// Set the count to a specific number
func (m *Counter) SetCount(c int) <span class="cov5" title="14">{
        m.lock.Lock()
        defer m.lock.Unlock()

        m.Count = c
        m.refresh()
}</span>

// Redraw the counter from the current count
func (m *Counter) refresh() <span class="cov10" title="162">{
        if m.Count &lt; 0 </span><span class="cov1" title="1">{
                m.Label.Text = "00"
        }</span> else<span class="cov9" title="161"> {
                m.Label.Text = fmt.Sprintf("%02d", m.Count)
        }</span>
        <span class="cov10" title="162">fyne.Do(m.Label.Refresh)</span>
}

// Increase the counter
func (m *Counter) Inc() <span class="cov6" title="17">{
        m.lock.Lock()
        defer m.lock.Unlock()

        m.Count++
        m.refresh()
}</span>

// Decrease the counter
func (m *Counter) Dec() <span class="cov9" title="131">{
        m.lock.Lock()
        defer m.lock.Unlock()

        m.Count--
        m.refresh()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "image/color"
        "log/slog"
        "sync"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

var (
        GridLabelColor = color.RGBA{240, 10, 20, alpha}
)

const (
        GridLabelSize float32 = 40

        ResetDefaultText          = "ðŸ™‚"
        ResetGameOverText         = "â˜ "
        ResetGameWonText          = "ðŸ˜Ž"
        ResetTextSize     float32 = 40
)

const (
        GameAlgorithmSafePos = iota
        GameAlgorithmSafeArea
        GameAlgorithmSolvable
)

const (
        ChunkSize = 10
)

// Graphical display for a minesweeper game
type MinesweeperGrid struct {
        Tiles         [][]*Tile
        Difficulty    minesweeper.Difficulty
        Game          minesweeper.Game
        AssistedMode  bool
        GameAlgorithm int

        solver *minesweeper.Solver

        Timer       *Timer
        MineCount   *Counter
        ResetButton *Button

        lUpdate    sync.Mutex
        lGame      sync.Mutex
        lAutosolve sync.Mutex

        autosolveBreak chan bool
        autosolveDone  chan bool

        testChannel chan string
}

// Create a new grid suitable for the give difficulty
func NewMinesweeperGrid(d minesweeper.Difficulty, assistedMode bool) *MinesweeperGrid <span class="cov4" title="57">{
        tiles := utils.Make2D[*Tile](d.Row, d.Col)
        grid := &amp;MinesweeperGrid{
                Tiles:         tiles,
                Difficulty:    d,
                AssistedMode:  assistedMode,
                GameAlgorithm: DEFAULT_GAME_ALGORITHM,
                Timer:         NewTimer(),
                MineCount:     NewCounter(d.Mines),
        }
        grid.ResetButton = NewButton(ResetDefaultText, color.RGBA{}, grid.NewGame)
        grid.ResetButton.Label.TextSize = ResetTextSize

        for x := 0; x &lt; grid.Row(); x++ </span><span class="cov6" title="682">{
                for y := 0; y &lt; grid.Col(); y++ </span><span class="cov8" title="11216">{
                        grid.Tiles[x][y] = NewTile(x, y, grid)
                }</span>
        }

        <span class="cov4" title="57">return grid</span>
}

// Get the graphical representation of the grid
func (g *MinesweeperGrid) GetCanvasObject() fyne.CanvasObject <span class="cov3" title="14">{
        mineCount := container.NewHBox(layout.NewSpacer(), container.NewCenter(newBorder(g.MineCount.Label)))
        reset := container.NewCenter(g.ResetButton)
        timer := container.NewHBox(container.NewCenter(newBorder(g.Timer.Label)), layout.NewSpacer())

        head := newBorder(container.NewGridWithColumns(3, mineCount, reset, timer))

        rows := make([]fyne.CanvasObject, len(g.Tiles))

        for x := 0; x &lt; g.Row(); x++ </span><span class="cov5" title="145">{
                col := make([]fyne.CanvasObject, g.Col())
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov7" title="1849">{
                        col[y] = g.Tiles[x][y]
                }</span>
                <span class="cov5" title="145">rows[x] = container.NewGridWithColumns(g.Col(), col...)</span>
        }
        <span class="cov3" title="14">body := newBorder(container.NewGridWithRows(g.Row(), rows...))
        return container.NewVBox(head, body)</span>
}

// Called by the child tiles to signal they have been tapped.
// Checks the given tile and then updates the display according to the new state.
// Starts a new game when no game is currently running.
func (g *MinesweeperGrid) TappedTile(pos minesweeper.Pos) <span class="cov5" title="256">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        if g.Game == nil </span><span class="cov3" title="18">{
                switch g.GameAlgorithm </span>{
                case GameAlgorithmSafePos:<span class="cov1" title="1">
                        g.Game = minesweeper.NewGameWithSafePos(g.Difficulty, pos)</span>
                case GameAlgorithmSafeArea:<span class="cov3" title="15">
                        g.Game = minesweeper.NewGameWithSafeArea(g.Difficulty, pos)</span>
                case GameAlgorithmSolvable:<span class="cov1" title="1">
                        g.Game = minesweeper.NewGameSolvable(g.Difficulty, pos)</span>
                default:<span class="cov1" title="1">
                        slog.Error("Unkown Algorithm for creating a new game", slog.Int("algorithm", g.GameAlgorithm))
                        return</span>
                }
        }
        <span class="cov5" title="255">if !g.Timer.Running() </span><span class="cov3" title="27">{
                g.Timer.Start()
        }</span>

        <span class="cov5" title="255">slog.Info("Checking field", slog.String("pos", pos.String()))

        s, changed := g.Game.CheckField(pos)
        if changed </span><span class="cov5" title="255">{
                slog.Debug("Checked field, updating tiles")
                g.updateFromStatus(s)
        }</span>

        <span class="cov5" title="255">if g.testChannel != nil </span><span class="cov1" title="1">{
                g.testChannel &lt;- "TappedTile"
        }</span>
}

// Called by the child tiles to reveal all neighbours when they have been double tapped
func (g *MinesweeperGrid) TapNeighbours(pos minesweeper.Pos) <span class="cov1" title="1">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        flags := minesweeper.FieldContent(0)
        posToCheck := make([]minesweeper.Pos, 0, 8)
        for m := -1; m &lt; 2; m++ </span><span class="cov1" title="3">{
                for n := -1; n &lt; 2; n++ </span><span class="cov2" title="9">{
                        p := pos
                        p.X += m
                        p.Y += n
                        if !g.OutOfBounds(p) </span><span class="cov2" title="9">{
                                if g.Tiles[p.X][p.Y].Flagged() </span><span class="cov1" title="1">{
                                        flags++
                                        continue</span>
                                }
                                <span class="cov2" title="8">if g.Tiles[p.X][p.Y].untappable() </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                                <span class="cov2" title="7">posToCheck = append(posToCheck, p)</span>
                        }
                }
        }

        <span class="cov1" title="1">if flags != g.Tiles[pos.X][pos.Y].Content() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">for _, p := range posToCheck </span><span class="cov2" title="7">{
                g.Game.CheckField(p)
        }</span>
        <span class="cov1" title="1">g.updateFromStatus(g.Game.Status())

        if g.testChannel != nil </span><span class="cov1" title="1">{
                g.testChannel &lt;- "TapNeighbours"
        }</span>
}

// Update the grid from the given status
func (g *MinesweeperGrid) updateFromStatus(s *minesweeper.Status) <span class="cov5" title="276">{
        if s == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov5" title="275">g.lUpdate.Lock()
        defer g.lUpdate.Unlock()

        var wg sync.WaitGroup

        if s.GameOver() || s.GameWon() </span><span class="cov2" title="7">{
                switch </span>{
                case s.GameWon():<span class="cov2" title="5">
                        slog.Info("Win")
                        g.ResetButton.SetText(ResetGameWonText)</span>
                case s.GameOver():<span class="cov1" title="2">
                        slog.Info("Game Over")
                        g.ResetButton.SetText(ResetGameOverText)</span>
                }
                <span class="cov2" title="7">g.Timer.Stop()</span>
        } else<span class="cov5" title="268"> if g.AssistedMode </span><span class="cov5" title="234">{
                if g.solver == nil </span><span class="cov1" title="1">{
                        g.solver = minesweeper.NewSolver(g.Game)
                }</span>
                <span class="cov5" title="234">g.solver.Update()

                wg.Add(2)
                slog.Debug("Creating Markers for Assisted Mode")
                go func() </span><span class="cov5" title="234">{
                        defer wg.Done()
                        for _, p := range g.solver.KnownMines() </span><span class="cov7" title="4041">{
                                g.Tiles[p.X][p.Y].Mark(HelpMarkingMine)
                        }</span>
                }()
                <span class="cov5" title="234">go func() </span><span class="cov5" title="234">{
                        defer wg.Done()
                        for _, p := range g.solver.NextSteps() </span><span class="cov7" title="2551">{
                                g.Tiles[p.X][p.Y].Mark(HelpMarkingSafe)
                        }</span>
                }()
        }

        <span class="cov5" title="275">for x := 0; x &lt;= g.Row()/ChunkSize; x++ </span><span class="cov6" title="496">{
                chunkSizeX := ChunkSize
                if x == g.Row()/ChunkSize </span><span class="cov5" title="275">{
                        if g.Row()%ChunkSize == 0 </span><span class="cov1" title="3">{
                                continue</span>
                        } else<span class="cov5" title="272"> {
                                chunkSizeX = g.Row() % ChunkSize
                        }</span>
                }
                <span class="cov6" title="493">startX := x * ChunkSize

                for y := 0; y &lt;= g.Col()/ChunkSize; y++ </span><span class="cov6" title="962">{
                        chunkSizeY := ChunkSize
                        if y == g.Col()/ChunkSize </span><span class="cov6" title="493">{
                                if g.Col()%ChunkSize == 0 </span><span class="cov3" title="13">{
                                        continue</span>
                                } else<span class="cov6" title="480"> {
                                        chunkSizeY = g.Col() % ChunkSize
                                }</span>
                        }

                        <span class="cov6" title="949">startY := y * ChunkSize

                        wg.Add(1)
                        go g.updateChunk(startX, startY, startX+chunkSizeX, startY+chunkSizeY, s, &amp;wg)</span>
                }
        }

        <span class="cov5" title="275">wg.Wait()
        slog.Debug("Finished Update")</span>
}

// Update a single chunk defined by the given dimensions
func (g *MinesweeperGrid) updateChunk(startX, startY, endX, endY int, s *minesweeper.Status, wg *sync.WaitGroup) <span class="cov6" title="949">{
        defer wg.Done()
        for x := startX; x &lt; endX; x++ </span><span class="cov8" title="7693">{
                for y := startY; y &lt; endY; y++ </span><span class="cov10" title="62808">{
                        if s.Field[x][y].Content == minesweeper.Unknown </span><span class="cov9" title="31821">{
                                continue</span>
                        }
                        <span class="cov9" title="30987">g.Tiles[x][y].SetField(s.Field[x][y])</span>
                }
        }
}

// Return the number of rows in the grid
func (g *MinesweeperGrid) Row() int <span class="cov7" title="3380">{
        return g.Difficulty.Row
}</span>

// Return the number of columns in the grid
func (g *MinesweeperGrid) Col() int <span class="cov9" title="31471">{
        return g.Difficulty.Col
}</span>

// Start a new game
func (g *MinesweeperGrid) NewGame() <span class="cov2" title="8">{
        g.reset()

        g.lGame.Lock()
        defer g.lGame.Unlock()

        slog.Info("Preparing for new game")
        g.Game = nil
        g.solver = nil
}</span>

// Replay the current game
func (g *MinesweeperGrid) Replay() <span class="cov2" title="4">{
        g.reset()

        g.lGame.Lock()
        defer g.lGame.Unlock()

        slog.Info("Preparing for replay of current game")
        if g.Game != nil </span><span class="cov2" title="4">{
                g.Game.Replay()
        }</span>
}

// Reset Grid
func (g *MinesweeperGrid) reset() <span class="cov3" title="12">{
        g.lAutosolve.Lock()
        defer g.lAutosolve.Unlock()

        if g.autosolveBreak != nil &amp;&amp; g.autosolveDone != nil </span><span class="cov1" title="2">{
                close(g.autosolveBreak)
                &lt;-g.autosolveDone
        }</span>

        <span class="cov3" title="12">g.lUpdate.Lock()
        defer g.lUpdate.Unlock()

        for x := 0; x &lt; g.Row(); x++ </span><span class="cov4" title="129">{
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov7" title="1721">{
                        g.Tiles[x][y].Reset()
                }</span>
        }
        <span class="cov3" title="12">g.MineCount.SetCount(g.Difficulty.Mines)
        g.Timer.Reset()
        g.ResetButton.SetText(ResetDefaultText)
        g.ResetButton.Refresh()
        slog.Debug("Reset grid")</span>
}

// Check if the given position is out of bounds.
// Calls Game.OutOfBounds(Pos)
func (g *MinesweeperGrid) OutOfBounds(p minesweeper.Pos) bool <span class="cov3" title="27">{
        return g.Game.OutOfBounds(p)
}</span>

// Display a single hint on the grid.
// Returns false if no hint could be displayed.
func (g *MinesweeperGrid) Hint() bool <span class="cov3" title="13">{
        if !g.gameRunning() </span><span class="cov1" title="2">{
                return false
        }</span>

        <span class="cov2" title="11">g.updateSolver()

        g.lUpdate.Lock()
        defer g.lUpdate.Unlock()

        for _, mine := range g.solver.KnownMines() </span><span class="cov4" title="44">{
                tile := g.Tiles[mine.X][mine.Y]
                if tile.Flagged() </span><span class="cov3" title="36">{
                        continue</span>
                }
                <span class="cov2" title="8">tile.Mark(HelpMarkingMine)
                return true</span>
        }
        <span class="cov1" title="3">safePos := g.solver.NextSteps()
        if len(safePos) &gt; 0 </span><span class="cov1" title="1">{
                g.Tiles[safePos[0].X][safePos[0].Y].Mark(HelpMarkingSafe)
                return true
        }</span>
        <span class="cov1" title="2">return false</span>
}

// Autosolve the current running game, delay is the time between steps
// Returns false if it can't run autosolve, otherwise true.
// If there are no steps to be taken, still returns true.
func (g *MinesweeperGrid) Autosolve(delay time.Duration) bool <span class="cov3" title="13">{
        if !g.gameRunning() </span><span class="cov1" title="3">{
                slog.Info("Autosolve failed because no game is running")
                return false
        }</span>

        <span class="cov2" title="10">s := g.gameStatus()

        if s == nil </span><span class="cov1" title="1">{
                slog.Info("Autosolve failed because game does not have a status yet")
                return false
        }</span>

        <span class="cov2" title="9">autosolveBreak := make(chan bool, 1)
        autosolveDone := make(chan bool, 1)
        alreadyRunning := false
        func() </span><span class="cov2" title="9">{
                g.lAutosolve.Lock()
                defer g.lAutosolve.Unlock()

                if g.autosolveBreak != nil &amp;&amp; g.autosolveDone != nil </span><span class="cov1" title="1">{
                        alreadyRunning = true
                }</span> else<span class="cov2" title="8"> {
                        g.autosolveBreak = autosolveBreak
                        g.autosolveDone = autosolveDone
                }</span>
        }()

        <span class="cov2" title="9">if alreadyRunning </span><span class="cov1" title="1">{
                slog.Debug("Autosolve already running, aborting")
                return false
        }</span>

        <span class="cov2" title="8">defer func() </span><span class="cov2" title="8">{
                close(autosolveDone)

                g.lAutosolve.Lock()
                defer g.lAutosolve.Unlock()

                g.autosolveBreak = nil
                g.autosolveDone = nil
        }</span>()

        <span class="cov2" title="8">g.updateSolver()

        oldAssistedModeStatus := g.AssistedMode
        g.AssistedMode = true
        defer func() </span><span class="cov2" title="8">{
                g.AssistedMode = oldAssistedModeStatus
        }</span>()
        <span class="cov2" title="8">g.updateFromStatus(s)

        for i, safePos := 0, g.solver.NextSteps(); len(safePos) &gt; 0 &amp;&amp; !s.GameOver() &amp;&amp; !s.GameWon(); safePos = g.solver.NextSteps() </span><span class="cov3" title="35">{
                mines := g.solver.KnownMines()

                slog.Debug("Autosolve: Checking safe positions", slog.Int("iteration", i))
                for _, p := range safePos </span><span class="cov5" title="246">{
                        if s.GameOver() || s.GameWon() </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov5" title="246">if g.Tiles[p.X][p.Y].Checked() </span><span class="cov3" title="27">{
                                continue</span>
                        }
                        <span class="cov5" title="219">g.TappedTile(p)
                        time.Sleep(delay)</span>
                }

                <span class="cov3" title="35">slog.Info("Autosolve: Flagging mines", slog.Int("iteration", i))
                for _, mine := range mines </span><span class="cov5" title="423">{
                        if s.GameOver() || s.GameWon() </span><span class="cov1" title="3">{
                                break</span>
                        }
                        <span class="cov5" title="420">tile := g.Tiles[mine.X][mine.Y]
                        tile.Flag(true)</span>
                }

                <span class="cov3" title="35">select </span>{
                case &lt;-autosolveBreak:<span class="cov1" title="2">
                        slog.Debug("Autosolve interrupted")
                        return true</span>
                default:<span class="cov3" title="33"></span>
                }

                <span class="cov3" title="33">g.updateSolver()
                i++</span>
        }

        <span class="cov2" title="6">if s.GameOver() || s.GameWon() </span><span class="cov1" title="3">{
                slog.Debug("Autosolve finished")
                return true
        }</span>

        <span class="cov1" title="3">slog.Info("Autosolve: Flagging mines a final time")
        for _, mine := range g.solver.KnownMines() </span><span class="cov4" title="81">{
                tile := g.Tiles[mine.X][mine.Y]
                tile.Flag(true)
        }</span>

        <span class="cov1" title="3">slog.Debug("Autosolve finished")
        return true</span>
}

// Check if a game is currently running
func (g *MinesweeperGrid) gameRunning() bool <span class="cov3" title="26">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        if g.Game == nil </span><span class="cov1" title="2">{
                return false
        }</span>
        <span class="cov3" title="24">return g.Game != nil &amp;&amp; !g.Game.Won() &amp;&amp; !g.Game.Lost()</span>
}

// Update the autosolver.
// Initializes the solver if it is nil.
// Expects the game to be != nil
func (g *MinesweeperGrid) updateSolver() <span class="cov4" title="52">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        if g.solver == nil </span><span class="cov2" title="10">{
                g.solver = minesweeper.NewSolver(g.Game)
        }</span>
        <span class="cov4" title="52">g.solver.Update()</span>
}

// Return the current games status.
// Can return nil.
func (g *MinesweeperGrid) gameStatus() *minesweeper.Status <span class="cov3" title="12">{
        g.lGame.Lock()
        defer g.lGame.Unlock()

        if g.Game == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="11">return g.Game.Status()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package locations

import (
        "log/slog"
        "os"
        "path/filepath"
)

const appName = "go-minesweeper"

const settingsFilename = "settings.yaml"

var saveFolder = ""

var settingsFile = ""

func SaveFolder() (string, error) <span class="cov8" title="7">{
        if saveFolder != "" </span><span class="cov6" title="5">{
                return saveFolder, nil
        }</span>

        <span class="cov3" title="2">var err error
        saveFolder, err = loadSaveFolderLocation()
        if err == nil </span><span class="cov3" title="2">{
                // #nosec G301 -- File permission should be determined by umask.
                return saveFolder, os.MkdirAll(saveFolder, 0755)
        }</span>
        <span class="cov0" title="0">slog.Error("Failed to load save folder location, falling back to current directory", "err", err)

        return os.Getwd()</span>
}

func SettingsFile() (string, error) <span class="cov10" title="12">{
        if settingsFile != "" </span><span class="cov9" title="10">{
                return settingsFile, nil
        }</span>

        <span class="cov3" title="2">var err error
        settingsFile, err = loadSettingsFileLocation()
        if err == nil </span><span class="cov3" title="2">{
                // #nosec G301 -- File permission should be determined by umask.
                return settingsFile, os.MkdirAll(filepath.Dir(settingsFile), 0755)
        }</span>
        <span class="cov0" title="0">slog.Error("Failed to load settings.yaml location, falling back to current directory", "err", err)

        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(pwd, settingsFilename), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//go:build linux

package locations

import (
        "os"
        "path/filepath"
)

func loadSaveFolderLocation() (string, error) <span class="cov10" title="4">{
        xdgDataHome := os.Getenv("XDG_DATA_HOME")
        if xdgDataHome != "" </span><span class="cov1" title="1">{
                return filepath.Join(xdgDataHome, "saves"), nil
        }</span>

        <span class="cov8" title="3">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="3">return filepath.Join(home, ".config", appName, "saves"), nil</span>
}

func loadSettingsFileLocation() (string, error) <span class="cov10" title="4">{
        xdgConfigHome := os.Getenv("XDG_CONFIG_HOME")
        if xdgConfigHome != "" </span><span class="cov1" title="1">{
                return filepath.Join(xdgConfigHome, settingsFilename), nil
        }</span>

        <span class="cov8" title="3">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="3">return filepath.Join(home, ".config", appName, settingsFilename), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "os"

        "github.com/heathcliff26/go-minesweeper/pkg/app/locations"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "sigs.k8s.io/yaml"
)

type Preferences struct {
        DifficultyInt int  `json:"difficulty"`
        AssistedMode  bool `json:"assistedMode"`
        GameAlgorithm int  `json:"gameAlgorithm"`
}

// Only used for testing, as we don't want to touch the actual file that might be on the system.
var overrideSettingsPath = ""

func defaultPreferences() Preferences <span class="cov7" title="13">{
        return Preferences{
                DifficultyInt: DEFAULT_DIFFICULTY,
                AssistedMode:  false,
                GameAlgorithm: DEFAULT_GAME_ALGORITHM,
        }
}</span>

// Load the preferences from the settings file.
// Return default values when an error occurs.
func LoadPreferences() (Preferences, error) <span class="cov6" title="9">{
        path, err := locations.SettingsFile()
        if err != nil </span><span class="cov0" title="0">{
                return defaultPreferences(), err
        }</span>
        <span class="cov6" title="9">if overrideSettingsPath != "" </span><span class="cov6" title="8">{
                path = overrideSettingsPath
        }</span>

        // #nosec G304 -- File path is hardcoded relative to user directory.
        <span class="cov6" title="9">f, err := os.ReadFile(path)
        if err != nil </span><span class="cov5" title="5">{
                return defaultPreferences(), err
        }</span>

        <span class="cov4" title="4">p := defaultPreferences()
        err = yaml.Unmarshal(f, &amp;p)
        if err != nil </span><span class="cov1" title="1">{
                return defaultPreferences(), err
        }</span>

        <span class="cov3" title="3">return p, nil</span>
}

// Convert the current app state to preferences that can be saved.
func CreatePreferencesFromApp(app *App) Preferences <span class="cov2" title="2">{
        difficulty := DEFAULT_DIFFICULTY
        for i, d := range app.difficulties </span><span class="cov6" title="7">{
                if d.Checked </span><span class="cov1" title="1">{
                        difficulty = i
                        break</span>
                }
        }

        <span class="cov2" title="2">gameAlgorithm := DEFAULT_GAME_ALGORITHM
        for i, algorithm := range app.gameAlgorithms </span><span class="cov4" title="4">{
                if algorithm.Checked </span><span class="cov1" title="1">{
                        gameAlgorithm = i
                        break</span>
                }
        }

        <span class="cov2" title="2">return Preferences{
                DifficultyInt: difficulty,
                AssistedMode:  app.assistedMode.Checked,
                GameAlgorithm: gameAlgorithm,
        }</span>
}

// Convert the saved difficulty number to an actual difficulty
func (p Preferences) Difficulty() minesweeper.Difficulty <span class="cov10" title="29">{
        difficulties := minesweeper.Difficulties()

        if p.DifficultyInt &lt; 0 || p.DifficultyInt &gt;= len(difficulties) </span><span class="cov2" title="2">{
                return difficulties[DEFAULT_DIFFICULTY]
        }</span>
        <span class="cov9" title="27">return difficulties[p.DifficultyInt]</span>
}

// Save the preferences to the settings file
func (p Preferences) Save() error <span class="cov1" title="1">{
        path, err := locations.SettingsFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if overrideSettingsPath != "" </span><span class="cov1" title="1">{
                path = overrideSettingsPath
        }</span>

        <span class="cov1" title="1">data, err := yaml.Marshal(&amp;p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // #nosec G306 -- File permission should be determined by umask.
        <span class="cov1" title="1">return os.WriteFile(path, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/theme"
)

const colorNameTileDefault = "tileDefault"

var (
        lightGray                    = color.RGBA{211, 211, 211, alpha}
        tileDefaultColorVariantLight = color.RGBA{180, 180, 180, alpha}
        tileDefaultColorVariantDark  = color.Gray16{32767}
)

var (
        // Ensure there are compile errors if the theme interface is not implemented
        _ fyne.Theme = mainTheme{}
        _ fyne.Theme = borderTheme{}
)

type mainTheme struct{}

func (mainTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color <span class="cov8" title="11322">{
        if variant == theme.VariantLight &amp;&amp; name == theme.ColorNameBackground </span><span class="cov1" title="3">{
                return lightGray
        }</span>
        <span class="cov8" title="11319">if name == colorNameTileDefault </span><span class="cov8" title="10672">{
                switch variant </span>{
                case theme.VariantLight:<span class="cov1" title="1">
                        return tileDefaultColorVariantLight</span>
                case theme.VariantDark:<span class="cov1" title="1">
                        return tileDefaultColorVariantDark</span>
                }
        }
        <span class="cov8" title="11317">return theme.DefaultTheme().Color(name, variant)</span>
}

func (mainTheme) Font(style fyne.TextStyle) fyne.Resource <span class="cov2" title="10">{
        return theme.DefaultTheme().Font(style)
}</span>

func (mainTheme) Icon(name fyne.ThemeIconName) fyne.Resource <span class="cov1" title="3">{
        return theme.DefaultTheme().Icon(name)
}</span>

func (mainTheme) Size(name fyne.ThemeSizeName) float32 <span class="cov10" title="95475">{
        return theme.DefaultTheme().Size(name)
}</span>

type borderTheme struct {
        mainTheme
}

func (borderTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color <span class="cov6" title="648">{
        if name == theme.ColorNameShadow </span><span class="cov5" title="198">{
                switch variant </span>{
                case theme.VariantLight:<span class="cov1" title="1">
                        return color.Black</span>
                case theme.VariantDark:<span class="cov1" title="1">
                        return color.White</span>
                }
        }
        <span class="cov6" title="646">return mainTheme{}.Color(name, variant)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">//go:generate fyne bundle --package assets --prefix Resource -o ../../assets/bundle_generated.go ../../img/mine.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag-success.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag-assisted.png

package app

import (
        "image/color"
        "sync"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/assets"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var (
        TileBackgroundColor = color.Gray16{^uint16(0)}
        TileExplodedColor   = color.RGBA{240, 10, 20, alpha}

        TileSize             = fyne.NewSize(32, 32)
        TileTextSize float32 = 23 // Biggest we can go with TileSize of 32^2
)

const alpha = ^uint8(0)

type HelpMarking int

const (
        HelpMarkingNone HelpMarking = iota
        HelpMarkingMine
        HelpMarkingSafe
)

var (
        HelperMarkerSymbols = []string{"", "!", "?"}
        HelperMarkerColors  = []color.Color{
                color.White,
                color.RGBA{180, 15, 15, alpha}, // Mine, red
                color.RGBA{15, 180, 15, alpha}, // Safe, green
        }
)

var TileTextColor = []color.Color{
        color.White,
        color.RGBA{20, 15, 220, alpha},  // 1, blue
        color.RGBA{5, 110, 20, alpha},   // 2, green
        color.RGBA{240, 10, 20, alpha},  // 3, red
        color.RGBA{5, 5, 100, alpha},    // 4, dark blue
        color.RGBA{90, 38, 42, alpha},   // 5, brown
        color.RGBA{25, 230, 230, alpha}, // 6, cyan
        color.RGBA{10, 10, 10, alpha},   // 7, black
        color.RGBA{64, 64, 64, alpha},   // 8, grey
}

// A tile extends the base widget and displays the current state of the backing games field
type Tile struct {
        widget.BaseWidget

        background *canvas.Rectangle
        label      *canvas.Text
        icon       *widget.Icon

        pos  minesweeper.Pos
        grid *MinesweeperGrid

        lFlag   sync.Mutex
        lUpdate sync.Mutex

        field   minesweeper.Field
        flagged bool
        marking HelpMarking
}

// Create a new Tile with a reference to it's parent grid, as well as knowledge of it's own position in the Grid
func NewTile(x, y int, grid *MinesweeperGrid) *Tile <span class="cov9" title="11216">{
        t := &amp;Tile{
                pos: minesweeper.NewPos(x, y),
                field: minesweeper.Field{
                        Checked: false,
                        Content: minesweeper.Unknown,
                },
                grid: grid,
        }
        t.ExtendBaseWidget(t)

        return t
}</span>

// Function to create renderer needed to implement widget
func (t *Tile) CreateRenderer() fyne.WidgetRenderer <span class="cov9" title="10492">{
        t.ExtendBaseWidget(t)

        t.background = canvas.NewRectangle(theme.Color(colorNameTileDefault))
        t.background.SetMinSize(TileSize)

        t.label = canvas.NewText("", color.White)
        t.label.TextStyle.Bold = true
        t.label.Alignment = fyne.TextAlignCenter
        t.label.TextSize = TileTextSize
        t.label.Hidden = true

        t.icon = widget.NewIcon(nil)
        t.icon.Resize(TileSize)
        t.icon.Hidden = true

        content := container.NewStack(t.background, t.icon, t.label)
        return widget.NewSimpleRenderer(content)
}</span>

// Left mouse click on tile
func (t *Tile) Tapped(_ *fyne.PointEvent) <span class="cov2" title="4">{
        if t.untappable() || t.Flagged() </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov1" title="3">go t.grid.TappedTile(t.pos)</span>
}

// Right mouse click on tile
func (t *Tile) TappedSecondary(_ *fyne.PointEvent) <span class="cov2" title="5">{
        if t.untappable() </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="4">if t.Flagged() &amp;&amp; t.Marking() == HelpMarkingMine </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="3">go t.Flag(!t.Flagged())</span>
}

// Double click on tile
func (t *Tile) DoubleTapped(_ *fyne.PointEvent) <span class="cov1" title="3">{
        if !t.Checked() || t.gameFinished() </span><span class="cov1" title="2">{
                return
        }</span>

        <span class="cov1" title="1">go t.grid.TapNeighbours(t.pos)</span>
}

// Update the tile render depending on the current state of it's backing Field.
// Calls to this function should wrap it in fyne.Do
func (t *Tile) Refresh() <span class="cov9" title="14675">{
        t.lUpdate.Lock()
        defer t.lUpdate.Unlock()

        defer canvas.Refresh(t)

        t.icon.Hidden = true
        t.label.Hidden = true
        t.background.FillColor = theme.Color(colorNameTileDefault)

        switch </span>{
        case t.Flagged() &amp;&amp; !t.Checked():<span class="cov5" title="190">
                switch </span>{
                case t.Content() == minesweeper.Mine &amp;&amp; t.Marking() != HelpMarkingMine:<span class="cov1" title="2">
                        t.icon.SetResource(assets.ResourceFlagSuccessPng)</span>
                case t.Marking() == HelpMarkingMine:<span class="cov5" title="178">
                        t.icon.SetResource(assets.ResourceFlagAssistedPng)</span>
                default:<span class="cov2" title="10">
                        t.icon.SetResource(assets.ResourceFlagPng)</span>
                }
                <span class="cov5" title="190">t.icon.Hidden = false</span>
        case t.Marking() != HelpMarkingNone &amp;&amp; !t.Flagged() &amp;&amp; !t.Checked() &amp;&amp; t.Content() == minesweeper.Unknown:<span class="cov6" title="461">
                t.label.Text = HelperMarkerSymbols[t.Marking()]
                t.label.Color = HelperMarkerColors[t.Marking()]
                t.label.Hidden = false</span>
        case t.Content() == minesweeper.Mine:<span class="cov8" title="5189">
                t.icon.SetResource(assets.ResourceMinePng)
                t.icon.Hidden = false
                if t.Checked() </span><span class="cov8" title="5131">{
                        t.background.FillColor = TileExplodedColor
                }</span>
        case t.Checked() &amp;&amp; t.Content() &gt; 0 &amp;&amp; t.Content() &lt; 9:<span class="cov6" title="762">
                t.label.Text = t.Content().String()
                t.label.Color = TileTextColor[t.Content()]
                t.label.Hidden = false
                t.background.FillColor = TileBackgroundColor</span>
        case t.Checked():<span class="cov6" title="521">
                t.background.FillColor = TileBackgroundColor</span>
        }
}

// Reset tile to default state, used for starting new game
func (t *Tile) Reset() <span class="cov7" title="1722">{
        t.flagged = false
        t.field.Checked = false
        t.field.Content = minesweeper.Unknown
        t.marking = HelpMarkingNone
        fyne.Do(t.Refresh)
}</span>

// Returns if the tiles field is checked
func (t *Tile) Checked() bool <span class="cov10" title="32073">{
        return t.field.Checked
}</span>

// Returns the field content
func (t *Tile) Content() minesweeper.FieldContent <span class="cov9" title="18264">{
        return t.field.Content
}</span>

// Set the content of the field
func (t *Tile) SetField(f minesweeper.Field) <span class="cov9" title="30987">{
        if f == t.field </span><span class="cov9" title="24209">{
                return
        }</span>
        <span class="cov8" title="6778">t.field = f
        fyne.Do(t.Refresh)</span>
}

// Returns if the tile is flagged as a suspected mine
func (t *Tile) Flagged() bool <span class="cov9" title="17944">{
        t.lFlag.Lock()
        defer t.lFlag.Unlock()

        return t.flagged
}</span>

// Flag the tile as a suspected mine
func (t *Tile) Flag(v bool) <span class="cov6" title="527">{
        t.lFlag.Lock()
        if v == t.flagged </span><span class="cov6" title="391">{
                t.lFlag.Unlock()
                return
        }</span>

        <span class="cov5" title="136">if t.flagged </span><span class="cov2" title="6">{
                t.grid.MineCount.Inc()
        }</span> else<span class="cov5" title="130"> {
                t.grid.MineCount.Dec()
        }</span>
        <span class="cov5" title="136">t.flagged = v

        t.lFlag.Unlock()
        fyne.Do(t.Refresh)</span>
}

// Returns the marking of the tile
func (t *Tile) Marking() HelpMarking <span class="cov9" title="24250">{
        return t.marking
}</span>

// Mark the tile
func (t *Tile) Mark(m HelpMarking) <span class="cov8" title="6604">{
        if m == t.Marking() </span><span class="cov8" title="6141">{
                return
        }</span>
        <span class="cov6" title="463">t.marking = m
        fyne.Do(t.Refresh)</span>
}

// Check if the tile should be clickable
func (t *Tile) untappable() bool <span class="cov3" title="22">{
        return t.Checked() || t.gameFinished()
}</span>

// Check if game is finished
func (t *Tile) gameFinished() bool <span class="cov3" title="20">{
        if t.grid.Game != nil </span><span class="cov3" title="12">{
                return t.grid.Game.Lost() || t.grid.Game.Won()
        }</span>
        <span class="cov2" title="8">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "fmt"
        "log/slog"
        "sync"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
)

// Timer to display an upwards countdown in a fyne app.
type Timer struct {
        Label      *canvas.Text
        Seconds    int
        stopSignal chan bool
        running    bool
        lock       sync.Mutex
}

// Create new timer
func NewTimer() *Timer <span class="cov6" title="61">{
        return &amp;Timer{
                Label:      newGridLabel("0000"),
                Seconds:    0,
                stopSignal: make(chan bool),
        }
}</span>

// Start the timer, runs concurrently
func (t *Timer) Start() <span class="cov5" title="31">{
        t.lock.Lock()
        defer t.lock.Unlock()

        if t.running </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov5" title="30">ticker := time.NewTicker(time.Second)
        t.running = true
        go func() </span><span class="cov5" title="30">{
                slog.Debug("Started timer")
                for </span><span class="cov10" title="1384">{
                        select </span>{
                        case &lt;-t.stopSignal:<span class="cov4" title="20">
                                ticker.Stop()
                                return</span>
                        case &lt;-ticker.C:<span class="cov9" title="1354">
                                t.Seconds++
                                t.refresh()</span>
                        }
                }
        }()
}

// Stop the timer
func (t *Timer) Stop() <span class="cov3" title="9">{
        t.lock.Lock()
        defer t.lock.Unlock()

        t.stop()
}</span>

// Reset the timer back to zero
func (t *Timer) Reset() <span class="cov4" title="13">{
        t.lock.Lock()
        defer t.lock.Unlock()

        t.stop()
        t.Seconds = 0
        t.refresh()
}</span>

// Actual stop logic, put here so lock can be aquired first by caller
func (t *Timer) stop() <span class="cov4" title="22">{
        if t.Running() </span><span class="cov4" title="20">{
                t.stopSignal &lt;- true
                t.running = false
                slog.Info("Stopped timer", slog.Int("seconds", t.Seconds))
        }</span>
}

// Check if the timer is running
func (t *Timer) Running() bool <span class="cov8" title="285">{
        return t.running
}</span>

// Refresh the timer from it's current values
func (t *Timer) refresh() <span class="cov9" title="1367">{
        t.Label.Text = fmt.Sprintf("%04d", t.Seconds)
        fyne.Do(t.Label.Refresh)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package app

import (
        "os"
        "path/filepath"
        "runtime"
        "runtime/debug"
        "strings"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/widget"
)

// NOTE: The $Format strings are replaced during 'git archive' thanks to the
// companion .gitattributes file containing 'export-subst' in this same
// directory.  See also https://git-scm.com/docs/gitattributes
var gitCommit string = "$Format:%H$" // sha1 from git, output of $(git rev-parse HEAD)

func init() <span class="cov1" title="1">{
        initGitCommit()
}</span>

func initGitCommit() <span class="cov3" title="3">{
        if strings.HasPrefix(gitCommit, "$Format") </span><span class="cov2" title="2">{
                var commit string
                buildinfo, _ := debug.ReadBuildInfo()
                for _, item := range buildinfo.Settings </span><span class="cov7" title="26">{
                        if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                                commit = item.Value
                                break</span>
                        }
                }
                <span class="cov2" title="2">gitCommit = commit</span>
        }
}

// Struct for containing the current version of the app
type Version struct {
        Name, Version, Commit, Go string
}

// Extract the version information from app
func getVersion(app fyne.App) Version <span class="cov4" title="7">{
        commit := gitCommit
        if len(commit) &gt; 7 </span><span class="cov1" title="1">{
                commit = commit[:7]
        }</span>

        <span class="cov4" title="7">metadata := app.Metadata()

        name, _ := strings.CutSuffix(metadata.Name, ".exe")
        if name == "" </span><span class="cov4" title="7">{
                name = filepath.Base(os.Args[0])
        }</span>

        <span class="cov4" title="7">return Version{
                Name:    name,
                Version: "v" + metadata.Version,
                Commit:  commit,
                Go:      runtime.Version(),
        }</span>
}

// Create the content for the version dialog
func getVersionContent(v Version) fyne.CanvasObject <span class="cov0" title="0">{
        data := [][]string{
                {"Version:", v.Version},
                {"Commit:", v.Commit},
                {"Go:", v.Go},
        }

        versionTable := widget.NewTable(
                func() (int, int) </span><span class="cov0" title="0">{
                        return len(data), len(data[0])
                }</span>,
                func() fyne.CanvasObject <span class="cov0" title="0">{
                        return widget.NewLabel("                ")
                }</span>,
                func(i widget.TableCellID, o fyne.CanvasObject) <span class="cov0" title="0">{
                        o.(*widget.Label).SetText(data[i.Row][i.Col])
                }</span>,
        )

        <span class="cov0" title="0">versionTable.ShowHeaderRow = false
        versionTable.ShowHeaderColumn = false
        versionTable.StickyRowCount = len(data) - 1
        versionTable.StickyColumnCount = len(data[0]) - 1
        versionTable.HideSeparators = true

        return versionTable</span>
}

// Wrap the objects in a box with border lines
func newBorder(content ...fyne.CanvasObject) fyne.CanvasObject <span class="cov8" title="56">{
        contentContainer := container.NewThemeOverride(container.NewPadded(content...), mainTheme{})
        border := widget.NewCard("", "", contentContainer)

        return container.NewThemeOverride(border, borderTheme{})
}</span>

// Create a new label used in the grid, with preset color, text size and text style
func newGridLabel(text string) *canvas.Text <span class="cov10" title="121">{
        label := canvas.NewText(text, GridLabelColor)
        label.TextSize = GridLabelSize
        label.TextStyle.Bold = true
        return label
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package minesweeper

const (
        DifficultyClassic      = iota
        DifficultyBeginner     = iota
        DifficultyIntermediate = iota
        DifficultyExpert       = iota
)

const (
        DifficultyRowColMin         = 8
        DifficultyRowColMax         = 99
        DifficultyMineMin           = 9
        DifficultyMineMaxPercentage = 0.8
)

// Represent a difficulty setting for the Game
type Difficulty struct {
        Name     string
        Row, Col int
        Mines    int
}

// Pre-defined difficulties
var difficulties []Difficulty = []Difficulty{
        {
                Name:  "Classic",
                Row:   8,
                Col:   8,
                Mines: 9,
        },
        {
                Name:  "Beginner",
                Row:   9,
                Col:   9,
                Mines: 10,
        },
        {
                Name:  "Intermediate",
                Row:   16,
                Col:   16,
                Mines: 40,
        },
        {
                Name:  "Expert",
                Row:   16,
                Col:   30,
                Mines: 99,
        },
}

// Exposes pre-defined difficulties in a way that does not allow the original array to be modified
func Difficulties() []Difficulty <span class="cov10" title="79">{
        list := make([]Difficulty, len(difficulties))
        copy(list, difficulties)
        return list
}</span>

func NewCustomDifficulty(mines, row, col int) (Difficulty, error) <span class="cov6" title="13">{
        if row &lt; DifficultyRowColMin || row &gt; DifficultyRowColMax || col &lt; DifficultyRowColMin || col &gt; DifficultyRowColMax </span><span class="cov3" title="4">{
                return Difficulty{}, NewErrDifficultyDimension(row, col)
        }</span>
        <span class="cov5" title="9">if mines &lt; DifficultyMineMin || float64(mines) &gt; float64(row*col)*DifficultyMineMaxPercentage </span><span class="cov2" title="2">{
                return Difficulty{}, NewErrDifficultyMineCount(mines)
        }</span>
        <span class="cov5" title="7">return Difficulty{
                Name:  "Custom",
                Row:   row,
                Col:   col,
                Mines: mines,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package minesweeper

import "fmt"

type ErrDifficultyDimension struct {
        row int
        col int
}

func NewErrDifficultyDimension(row, col int) error <span class="cov10" title="8">{
        return &amp;ErrDifficultyDimension{row, col}
}</span>

func (e *ErrDifficultyDimension) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Rows and Columns need to be between %d and %d, got %dx%d", DifficultyRowColMin, DifficultyRowColMax, e.row, e.col)
}</span>

type ErrDifficultyMineCount struct {
        mines int
}

func NewErrDifficultyMineCount(mines int) error <span class="cov7" title="4">{
        return &amp;ErrDifficultyMineCount{mines}
}</span>

func (e *ErrDifficultyMineCount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("The number of mines need to be between %d and %.1f %% of the total number of cells, got %d", DifficultyMineMin, DifficultyMineMaxPercentage*100, e.mines)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package minesweeper

import (
        "log/slog"

        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

// Represents the content of a field.
// Can be a mine, unknown or the number of mines in the neighboring fields
type FieldContent int

const (
        Mine    FieldContent = -1
        Unknown FieldContent = -2
)

// Represents a single field in a minefield
type Field struct {
        Checked bool
        Content FieldContent
}

// Interface for playing the game
type Game interface {
        // Check a given field and recursevly reveal all neighboring fields that should be revield.
        // Returns the resulting new status of the game
        CheckField(p Pos) (*Status, bool)
        // Check if the given position is out of bounds
        OutOfBounds(p Pos) bool
        // Returns the current status of the game. Only contains the knowledge a player should have.
        Status() *Status
        // Return the difficulty of the game
        Difficulty() Difficulty
        // Check if Game Over
        Lost() bool
        // Check if the game is won
        Won() bool
        // Reset the current game to be played again
        Replay()
        // Check if the game is a replay
        IsReplay() bool
        // Generate a save from the game
        ToSave() (*Save, error)
}

// Ensure that compiler throws error if LocalGame does not implement Game interface
var _ = Game(&amp;LocalGame{})

type LocalGame struct {
        Field      [][]Field
        difficulty Difficulty

        // Keep these 2 exported for testing in other packages
        GameOver bool
        GameWon  bool

        // Cache the last status
        status *Status

        replay bool
}

// Utility function to create empty game
func blankGame(d Difficulty) *LocalGame <span class="cov3" title="103">{
        return &amp;LocalGame{
                Field:      utils.Make2D[Field](d.Row, d.Col),
                difficulty: d,
                GameOver:   false,
                GameWon:    false,
        }
}</span>

// Create a new game with the mines in the given positions
func newGame(d Difficulty, mines []Pos) *LocalGame <span class="cov3" title="78">{
        g := blankGame(d)

        for _, mine := range mines </span><span class="cov6" title="4361">{
                g.Field[mine.X][mine.Y].Content = Mine
        }</span>

        <span class="cov3" title="78">g.calculateFieldContent()

        return g</span>
}

// Create a new game with mines seeded randomly in the map, with the exception of the given position.
func NewGameWithSafePos(d Difficulty, p Pos) *LocalGame <span class="cov3" title="40">{
        mines := CreateMines(d, []Pos{p})

        return newGame(d, mines)
}</span>

// Create a new game with mines seeded randomly in the map, with the exception of a 3x3 area around the given position.
func NewGameWithSafeArea(d Difficulty, p Pos) *LocalGame <span class="cov2" title="20">{
        mines := CreateMines(d, areaAroundPos(d, p))

        return newGame(d, mines)
}</span>

// Create a new game that is solvable without random guesses.
func NewGameSolvable(d Difficulty, p Pos) *LocalGame <span class="cov1" title="4">{
        area := areaAroundPos(d, p)

        var mines []Pos
        var success bool
        for i := 0; i &lt; 10000; i++ </span><span class="cov2" title="14">{
                mines = CreateMines(d, area)
                g := newGame(d, mines)
                s := NewSolver(g)

                if success = s.Autosolve(p); success </span><span class="cov1" title="4">{
                        break</span>
                }
        }
        <span class="cov1" title="4">if success </span><span class="cov1" title="4">{
                slog.Info("Created solvable minesweeper game")
        }</span> else<span class="cov0" title="0"> {
                slog.Error("Failed to create a solvable minesweeper game")
        }</span>

        <span class="cov1" title="4">return newGame(d, mines)</span>
}

// Check a given field and recursevly reveal all neighboring fields that should be revield.
// Returns the resulting new status of the game and a boolean indicating if there where changes.
func (g *LocalGame) CheckField(p Pos) (*Status, bool) <span class="cov5" title="2043">{
        if g.Lost() || g.Won() || g.Field[p.X][p.Y].Checked </span><span class="cov4" title="171">{
                return g.Status(), false
        }</span>

        <span class="cov5" title="1872">g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content == Mine </span><span class="cov1" title="2">{
                g.GameOver = true
                return g.UpdateStatus(), true
        }</span>

        <span class="cov5" title="1870">g.revealField(p)

        return g.UpdateStatus(), true</span>
}

// Recursive function to reveal all neighbouring fields that can be safely reveald.
// Stops when a field has not exactly zero neighbouring mines
func (g *LocalGame) revealField(p Pos) <span class="cov6" title="5211">{
        slog.Debug("Reveal field", slog.String("pos", p.String()), slog.String("content", g.Field[p.X][p.Y].Content.String()))

        g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content != 0 </span><span class="cov6" title="3546">{
                return
        }</span>

        <span class="cov5" title="1665">slog.Debug("Revealing fields neigbhours", slog.String("pos", p.String()))

        for m := -1; m &lt; 2; m++ </span><span class="cov6" title="4995">{
                for n := -1; n &lt; 2; n++ </span><span class="cov7" title="14985">{
                        if m == 0 &amp;&amp; n == 0 </span><span class="cov5" title="1665">{
                                continue</span>
                        }
                        <span class="cov7" title="13320">i := NewPos(p.X+m, p.Y+n)
                        if g.OutOfBounds(i) </span><span class="cov5" title="2233">{
                                continue</span>
                        }
                        <span class="cov6" title="11087">if !g.Field[i.X][i.Y].Checked </span><span class="cov6" title="3341">{
                                g.revealField(i)
                        }</span>
                }
        }
}

// Check if the given position is out of bounds
func (g *LocalGame) OutOfBounds(p Pos) bool <span class="cov8" title="209464">{
        if g == nil </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov8" title="209463">return OutOfBounds(p, g.Difficulty())</span>
}

// Returns the current status of the game. Only contains the knowledge a player should have.
func (g *LocalGame) Status() *Status <span class="cov5" title="1771">{
        return g.status
}</span>

// Return the difficulty of the game
func (g *LocalGame) Difficulty() Difficulty <span class="cov10" title="1227020">{
        return g.difficulty
}</span>

// Update the status from the current state of the game.
// Returns status for convenience.
func (g *LocalGame) UpdateStatus() *Status <span class="cov5" title="1891">{
        if g.status == nil </span><span class="cov3" title="83">{
                g.status = &amp;Status{
                        Field:    utils.Make2D[Field](g.difficulty.Row, g.difficulty.Col),
                        gameOver: g.Lost(),
                        gameWon:  g.Won(),
                }
        }</span>

        <span class="cov5" title="1891">wasWon := g.Won()
        isWon := true

        g.walkField(func(x, y int) </span><span class="cov9" title="605507">{
                g.status.Field[x][y].Checked = g.Field[x][y].Checked
                if g.Field[x][y].Checked || g.Lost() || g.Won() </span><span class="cov9" title="271899">{
                        g.status.Field[x][y].Content = g.Field[x][y].Content
                }</span> else<span class="cov9" title="333608"> {
                        g.status.Field[x][y].Content = Unknown
                }</span>
                <span class="cov9" title="605507">if !g.Field[x][y].Checked &amp;&amp; g.Field[x][y].Content != Mine </span><span class="cov8" title="222998">{
                        isWon = false
                }</span>
        })

        <span class="cov5" title="1891">if !wasWon &amp;&amp; isWon </span><span class="cov2" title="17">{
                g.GameWon = isWon
                for x := 0; x &lt; g.difficulty.Row; x++ </span><span class="cov4" title="208">{
                        copy(g.status.Field[x], g.Field[x])
                }</span>
        }

        <span class="cov5" title="1891">g.status.gameOver = g.GameOver
        g.status.gameWon = g.GameWon

        return g.status</span>
}

// Check if Game Over
func (g *LocalGame) Lost() bool <span class="cov9" title="337333">{
        return g.GameOver
}</span>

// Check if the game is won
func (g *LocalGame) Won() bool <span class="cov9" title="338544">{
        return g.GameWon
}</span>

// Reset the current game to be played again
func (g *LocalGame) Replay() <span class="cov2" title="5">{
        g.replay = true
        g.GameOver = false
        g.GameWon = false
        g.status = nil

        g.walkField(func(x, y int) </span><span class="cov5" title="580">{
                g.Field[x][y].Checked = false
        }</span>)
}

// Check if the game is a replay
func (g *LocalGame) IsReplay() bool <span class="cov1" title="4">{
        return g.replay
}</span>

// Generate a save from the game
func (g *LocalGame) ToSave() (*Save, error) <span class="cov1" title="4">{
        g.replay = true
        return NewSave(g)
}</span>

// Walk through all fields of the game and call the given function
func (g *LocalGame) walkField(f func(x, y int)) <span class="cov5" title="2034">{
        walkField(f, g.difficulty.Row, g.difficulty.Col)
}</span>

// Count the the number of mines in the neighboring fields
func (g *LocalGame) countNearbyMines(p Pos) int <span class="cov7" title="21524">{
        c := 0
        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="64572">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="193716">{
                        if g.OutOfBounds(NewPos(p.X+m, p.Y+n)) </span><span class="cov7" title="15730">{
                                continue</span>
                        }
                        <span class="cov8" title="177986">if g.Field[p.X+m][p.Y+n].Content == Mine </span><span class="cov7" title="32552">{
                                c++
                        }</span>
                }
        }
        <span class="cov7" title="21524">return c</span>
}

// Get a list of all mines in the game
func (g *LocalGame) getMines() []Pos <span class="cov1" title="4">{
        mines := make([]Pos, 0, g.difficulty.Mines)

        g.walkField(func(x, y int) </span><span class="cov4" title="499">{
                if g.Field[x][y].Content == Mine </span><span class="cov3" title="70">{
                        mines = append(mines, NewPos(x, y))
                }</span>
        })
        <span class="cov1" title="4">return mines</span>
}

// Calculate all fields with the count of neighbouring mines
func (g *LocalGame) calculateFieldContent() <span class="cov3" title="103">{
        g.walkField(func(x, y int) </span><span class="cov7" title="24588">{
                if g.Field[x][y].Content == Mine </span><span class="cov6" title="5614">{
                        return
                }</span>

                <span class="cov7" title="18974">g.Field[x][y].Content = FieldContent(g.countNearbyMines(NewPos(x, y)))</span>
        })
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package minesweeper

import (
        "crypto/sha512"
        "encoding/hex"
        "encoding/json"
        "os"
        "path/filepath"
)

const SaveFileExtension = ".sav"

type Save struct {
        // ID is the hash generated from the Data
        ID string `json:"id"`
        // Data contains everything necessary to create a game
        Data saveData `json:"data"`
}

type saveData struct {
        Mines      []Pos      `json:"mines"`
        Difficulty Difficulty `json:"difficulty"`
}

// Create a new save from the given game
func NewSave(game *LocalGame) (*Save, error) <span class="cov2" title="4">{
        data := saveData{
                Mines:      game.getMines(),
                Difficulty: game.Difficulty(),
        }

        buf, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="4">hash := sha512.Sum512(buf)

        return &amp;Save{
                ID:   hex.EncodeToString(hash[:]),
                Data: data,
        }, nil</span>
}

// Load a save file from the given path
func LoadSave(path string) (*Save, error) <span class="cov5" title="27">{
        // #nosec G304 -- Local users can decide on their file path themselves.
        buf, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="27">var save Save
        err = json.Unmarshal(buf, &amp;save)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="27">return &amp;save, nil</span>
}

// Write save file to the given path.
// Needs to have the correct extension.
func (s *Save) Save(path string) error <span class="cov3" title="5">{
        if filepath.Ext(path) != SaveFileExtension </span><span class="cov1" title="2">{
                path += SaveFileExtension
        }</span>

        <span class="cov3" title="5">data, err := json.MarshalIndent(s, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // #nosec G306 -- File permission should be determined by umask.
        <span class="cov3" title="5">return os.WriteFile(path, data, 0644)</span>
}

// Creates a LocalGame from the save.
// The game will be considered a replay
func (s *Save) Game() *LocalGame <span class="cov5" title="25">{
        g := blankGame(s.Data.Difficulty)

        for _, p := range s.Data.Mines </span><span class="cov10" title="1253">{
                g.Field[p.X][p.Y].Content = Mine
        }</span>

        <span class="cov5" title="25">g.calculateFieldContent()

        g.replay = true

        return g</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package minesweeper

import (
        "log/slog"
        "slices"
        "sync"
)

type Solver struct {
        game Game

        mines     []Pos
        nextSteps []Pos

        lock sync.RWMutex
}

func NewSolver(g Game) *Solver <span class="cov3" title="43">{
        return &amp;Solver{
                game: g,
        }
}</span>

func (s *Solver) NextSteps() []Pos <span class="cov5" title="1677">{
        s.lock.RLock()
        defer s.lock.RUnlock()

        return s.nextSteps
}</span>

func (s *Solver) KnownMines() []Pos <span class="cov5" title="1445">{
        s.lock.RLock()
        defer s.lock.RUnlock()

        return s.mines
}</span>

func (s *Solver) Update() <span class="cov5" title="1581">{
        s.lock.Lock()
        defer s.lock.Unlock()

        status := s.game.Status()
        if status == nil || status.GameOver() || status.GameWon() </span><span class="cov2" title="16">{
                return
        }</span>

        <span class="cov5" title="1565">if s.mines == nil </span><span class="cov3" title="42">{
                s.mines = make([]Pos, 0, s.game.Difficulty().Mines)
        }</span>
        <span class="cov5" title="1565">nextSteps := make([]Pos, 0, 25)
        for _, p := range s.nextSteps </span><span class="cov6" title="5010">{
                if !status.Field[p.X][p.Y].Checked </span><span class="cov6" title="3013">{
                        nextSteps = append(nextSteps, p)
                }</span>
        }
        <span class="cov5" title="1565">s.nextSteps = nextSteps

        i := 0
        oldLenMines := -1
        oldLenSafe := -1
        for len(s.mines) &gt; oldLenMines || len(s.nextSteps) &gt; oldLenSafe </span><span class="cov6" title="2223">{
                i++
                oldLenMines = len(s.mines)
                oldLenSafe = len(s.nextSteps)
                walkField(func(x, y int) </span><span class="cov9" title="411126">{
                        if !status.Field[x][y].Checked || status.Field[x][y].Content &lt;= 0 </span><span class="cov9" title="298565">{
                                return
                        }</span>

                        <span class="cov8" title="112561">unchecked := FieldContent(0)
                        mines := FieldContent(0)
                        safePos := FieldContent(0)
                        newPos := make([]Pos, 0, 8)
                        for m := -1; m &lt; 2; m++ </span><span class="cov9" title="337683">{
                                for n := -1; n &lt; 2; n++ </span><span class="cov10" title="1013049">{
                                        p := NewPos(x+m, y+n)
                                        if OutOfBounds(p, s.game.Difficulty()) </span><span class="cov7" title="44148">{
                                                continue</span>
                                        }
                                        <span class="cov9" title="968901">if !status.Field[p.X][p.Y].Checked </span><span class="cov9" title="230061">{
                                                unchecked++
                                                if slices.Contains(s.mines, p) </span><span class="cov8" title="168890">{
                                                        mines++
                                                }</span> else<span class="cov8" title="61171"> if !slices.Contains(s.nextSteps, p) </span><span class="cov7" title="39229">{
                                                        newPos = append(newPos, p)
                                                }</span> else<span class="cov7" title="21942"> {
                                                        safePos++
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="112561">if len(newPos) == 0 </span><span class="cov8" title="97518">{
                                return
                        }</span>
                        <span class="cov7" title="15043">if unchecked-safePos == status.Field[x][y].Content &amp;&amp; mines != status.Field[x][y].Content </span><span class="cov5" title="771">{
                                slog.Debug("Assisted Mode: Found mines near field",
                                        slog.String("pos", NewPos(x, y).String()),
                                        slog.Int("mines", int(mines)),
                                        slog.Int("unchecked", int(unchecked)),
                                        slog.Int("content", int(status.Field[x][y].Content)),
                                        slog.Any("newPos", newPos),
                                )
                                s.mines = append(s.mines, newPos...)
                        }</span> else<span class="cov7" title="14272"> if mines == status.Field[x][y].Content &amp;&amp; unchecked &gt; status.Field[x][y].Content </span><span class="cov5" title="1336">{
                                slog.Debug("Assisted Mode: Found safe positions near field",
                                        slog.String("pos", NewPos(x, y).String()),
                                        slog.Int("mines", int(mines)),
                                        slog.Int("unchecked", int(unchecked)),
                                        slog.Int("content", int(status.Field[x][y].Content)),
                                        slog.Any("newPos", newPos),
                                )
                                s.nextSteps = append(s.nextSteps, newPos...)
                        }</span>
                }, s.game.Difficulty().Row, s.game.Difficulty().Col)
        }

        <span class="cov5" title="1565">slog.Debug("Assisted Mode: Mines and safe Positions found", slog.Any("mines", s.mines), slog.Any("safe", s.nextSteps), slog.Int("iterations", i))</span>
}

// Autosolve the game.
// Returns if the game can be autosolved
func (s *Solver) Autosolve(startPos Pos) bool <span class="cov3" title="27">{
        s.game.CheckField(startPos)

        s.Update()

        for safePos := s.NextSteps(); len(safePos) &gt; 0 &amp;&amp; !s.game.Won(); safePos = s.NextSteps() </span><span class="cov4" title="213">{
                for _, p := range safePos </span><span class="cov5" title="1688">{
                        s.game.CheckField(p)
                }</span>
                <span class="cov4" title="213">s.Update()</span>
        }

        <span class="cov3" title="27">return s.game.Won()</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package minesweeper

// Status contains the current state of the game known to the player.
// As such it will always be a copy and needs to be it's own type, despite the
// overlapping similarities.
// It does not support any of the functions that Game does.
// It is safe to write to Status, as it is merely a copy.
type Status struct {
        Field    [][]Field
        gameOver bool
        gameWon  bool
}

// Returns if the game is lost
func (s *Status) GameOver() bool <span class="cov9" title="2572">{
        return s.gameOver
}</span>

// Returns if the game is won
func (s *Status) GameWon() bool <span class="cov10" title="2577">{
        return s.gameWon
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package minesweeper

import (
        "fmt"
        "math/rand/v2"
        "slices"
        "strconv"
)

// Represent a position in the minefield
type Pos struct {
        X, Y int
}

// Create a new Position from the given coordinates
func NewPos(x, y int) Pos <span class="cov10" title="1264809">{
        return Pos{x, y}
}</span>

// Returns a random position inside the provided limits
func RandomPos(maxX, maxY int) Pos <span class="cov6" title="6560">{
        // #nosec G304,G404 -- This is not a security sensitive task, so using the less resource intensive pseudo-random algorithm is fine.
        return NewPos(rand.IntN(maxX), rand.IntN(maxY))
}</span>

// Returns a string representation of the position
func (p Pos) String() string <span class="cov7" title="13980">{
        return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}</span>

// Randomly create mines for the given difficulty.
// Does not create a mine on the given positions.
func CreateMines(d Difficulty, safe []Pos) []Pos <span class="cov3" title="79">{
        var p Pos
        mines := make([]Pos, 0, d.Mines+len(safe))

        mines = append(mines, safe...)
        for i := 0; i &lt; d.Mines; i++ </span><span class="cov6" title="5450">{
                p = RandomPos(d.Row, d.Col)
                for slices.Contains(mines, p) </span><span class="cov5" title="1105">{
                        p = RandomPos(d.Row, d.Col)
                }</span>
                <span class="cov6" title="5450">mines = append(mines, p)</span>
        }
        <span class="cov3" title="79">return mines[len(safe):]</span>
}

// Convert FieldContent to string for logging
func (fc FieldContent) String() string <span class="cov6" title="5986">{
        switch </span>{
        case fc == Mine:<span class="cov1" title="1">
                return "Mine"</span>
        case fc == Unknown:<span class="cov1" title="1">
                return "Unknown"</span>
        case fc &gt;= 0 &amp;&amp; fc &lt; 9:<span class="cov6" title="5982">
                return strconv.Itoa(int(fc))</span>
        default:<span class="cov1" title="2">
                return fmt.Sprintf("%d is not a valid FieldContent", fc)</span>
        }
}

// Check if a position is out of bounds on the given difficulty
func OutOfBounds(p Pos, d Difficulty) bool <span class="cov9" title="1222728">{
        return p.X &lt; 0 || p.X &gt; d.Row-1 || p.Y &lt; 0 || p.Y &gt; d.Col-1
}</span>

// Walk through all fields in the given dimension and call the given function
func walkField(f func(x, y int), limitX, limitY int) <span class="cov6" title="4257">{
        for x := 0; x &lt; limitX; x++ </span><span class="cov8" title="57152">{
                for y := 0; y &lt; limitY; y++ </span><span class="cov9" title="1048736">{
                        f(x, y)
                }</span>
        }
}

// Create an array of positions with 3x3, centered around the given position
func areaAroundPos(d Difficulty, p Pos) []Pos <span class="cov3" title="24">{
        area := make([]Pos, 0, 9)
        for x := -1; x &lt; 2; x++ </span><span class="cov3" title="72">{
                for y := -1; y &lt; 2; y++ </span><span class="cov4" title="216">{
                        p := NewPos(p.X+x, p.Y+y)
                        if !OutOfBounds(p, d) </span><span class="cov4" title="141">{
                                area = append(area, p)
                        }</span>
                }
        }
        <span class="cov3" title="24">return area</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package utils

// Create a new, empty 2 dimensional array of the given type and dimensions.
func Make2D[T any](x, y int) [][]T <span class="cov7" title="255">{
        if x &lt; 1 || y &lt; 1 </span><span class="cov2" title="6">{
                return [][]T{}
        }</span>

        <span class="cov7" title="249">matrix := make([][]T, x)
        rows := make([]T, x*y)

        for i := 0; i &lt; x; i++ </span><span class="cov10" title="3177">{
                matrix[i] = rows[i*y : (i+1)*y]
        }</span>
        <span class="cov7" title="249">return matrix</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
