
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/go-minesweeper/pkg/app/app.go (58.5%)</option>
				
				<option value="file1">github.com/heathcliff26/go-minesweeper/pkg/app/button.go (100.0%)</option>
				
				<option value="file2">github.com/heathcliff26/go-minesweeper/pkg/app/counter.go (100.0%)</option>
				
				<option value="file3">github.com/heathcliff26/go-minesweeper/pkg/app/grid.go (98.4%)</option>
				
				<option value="file4">github.com/heathcliff26/go-minesweeper/pkg/app/tile.go (100.0%)</option>
				
				<option value="file5">github.com/heathcliff26/go-minesweeper/pkg/app/timer.go (100.0%)</option>
				
				<option value="file6">github.com/heathcliff26/go-minesweeper/pkg/app/utils.go (59.5%)</option>
				
				<option value="file7">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/difficulty.go (100.0%)</option>
				
				<option value="file8">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/errors.go (50.0%)</option>
				
				<option value="file9">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/game.go (100.0%)</option>
				
				<option value="file10">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/utils.go (100.0%)</option>
				
				<option value="file11">github.com/heathcliff26/go-minesweeper/pkg/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//go:generate fyne bundle --package assets --prefix Resource -o ../../assets/bundle_generated.go ../../img/mine.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag.png
package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        fApp "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/data/binding"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var TEXT_COLOR = color.White

var DEFAULT_DIFFICULTY = minesweeper.Difficulties()[minesweeper.DifficultyIntermediate]

// Used to change the new app function for testing
var newApp = fApp.New

// Struct representing the current app.
// There should only ever be a single instance during runtime.
type App struct {
        app          fyne.App
        main         fyne.Window
        Version      Version
        grid         *MinesweeperGrid
        difficulties []*fyne.MenuItem
}

// Create a new App
func New() *App <span class="cov8" title="1">{
        app := newApp()
        version := getVersion(app)
        main := app.NewWindow(version.Name)

        a := &amp;App{
                app:     app,
                main:    main,
                Version: version,
                grid:    NewMinesweeperGrid(DEFAULT_DIFFICULTY),
        }

        a.main.SetTitle(version.Name)
        a.makeMenu()
        a.main.SetMainMenu(a.makeMenu())

        a.setContent()

        a.main.SetFixedSize(true)
        a.main.Show()

        return a
}</span>

// Simply calls app.Run()
func (a *App) Run() <span class="cov0" title="0">{
        a.app.Run()
}</span>

// Create the main menu bar
func (a *App) makeMenu() *fyne.MainMenu <span class="cov8" title="1">{
        // Can't assign grid functions directly, as the instance of grid may change
        newGameOption := fyne.NewMenuItem("New", func() </span><span class="cov0" title="0">{
                a.grid.NewGame()
        }</span>)
        <span class="cov8" title="1">replayOption := fyne.NewMenuItem("Replay", func() </span><span class="cov0" title="0">{
                a.grid.Replay()
        }</span>)
        <span class="cov8" title="1">gameMenu := fyne.NewMenu("Game", newGameOption, replayOption)

        difficulties := minesweeper.Difficulties()
        diffItems := make([]*fyne.MenuItem, 0, len(difficulties)+2)
        for _, d := range difficulties </span><span class="cov8" title="1">{
                diff := d
                item := fyne.NewMenuItem(d.Name, nil)
                item.Action = func() </span><span class="cov8" title="1">{
                        if item.Checked </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">for _, i := range a.difficulties </span><span class="cov8" title="1">{
                                i.Checked = (i.Label == diff.Name)
                        }</span>
                        <span class="cov8" title="1">a.grid = NewMinesweeperGrid(diff)
                        a.setContent()</span>
                }
                <span class="cov8" title="1">item.Checked = (d == DEFAULT_DIFFICULTY)
                diffItems = append(diffItems, item)</span>
        }
        <span class="cov8" title="1">diffItems = append(diffItems, fyne.NewMenuItemSeparator())
        diffItems = append(diffItems, fyne.NewMenuItem("Custom", a.customDifficultyDialog))
        a.difficulties = diffItems
        diffMenu := fyne.NewMenu("Difficulties", diffItems...)

        about := fyne.NewMenuItem("About", func() </span><span class="cov0" title="0">{
                vInfo := dialog.NewCustom(a.Version.Name, "close", getVersionContent(a.Version), a.main)
                vInfo.Show()
        }</span>)
        <span class="cov8" title="1">helpMenu := fyne.NewMenu("Help", about)

        return fyne.NewMainMenu(gameMenu, diffMenu, helpMenu)</span>
}

// Update the content of the app and resize the window to make it fit
func (a *App) setContent() <span class="cov8" title="1">{
        content := container.NewPadded(a.grid.GetCanvasObject())
        content.Resize(content.MinSize())

        a.main.SetContent(content)
        a.main.Resize(content.MinSize())
}</span>

// Show a dialog for setting a custom difficulty
func (a *App) customDifficultyDialog() <span class="cov0" title="0">{
        mines := minesweeper.DifficultyMineMin
        row, col := minesweeper.DifficultyRowColMin, minesweeper.DifficultyRowColMin

        mineLabel := canvas.NewText("Mines", TEXT_COLOR)
        mineEntry := widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;mines)))
        rowLabel := canvas.NewText("Rows", TEXT_COLOR)
        rowEntry := widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;row)))
        colLabel := canvas.NewText("Columns", TEXT_COLOR)
        colEntry := widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;col)))

        content := container.NewGridWithColumns(2, mineLabel, mineEntry, rowLabel, rowEntry, colLabel, colEntry)
        diffDialog := dialog.NewCustomConfirm("Custom Difficulty", "ok", "cancel", content, func(ok bool) </span><span class="cov0" title="0">{
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">d, err := minesweeper.NewCustomDifficulty(mines, row, col)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">for _, i := range a.difficulties </span><span class="cov0" title="0">{
                        i.Checked = (i.Label == "Custom")
                }</span>
                <span class="cov0" title="0">a.grid = NewMinesweeperGrid(d)
                a.setContent()</span>
        }, a.main)
        <span class="cov0" title="0">diffDialog.Show()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/widget"
)

// Custom implementation for a button that is only portraied by text.
// The text is fully configurable by exposing the backing label.
type Button struct {
        widget.BaseWidget

        Label  *canvas.Text
        Action func()
}

// Create a new button from the given text, color and function
func NewButton(text string, color color.Color, action func()) *Button <span class="cov8" title="1">{
        b := &amp;Button{
                Label:  canvas.NewText(text, color),
                Action: action,
        }
        b.ExtendBaseWidget(b)
        return b
}</span>

// Function to create renderer needed to implement widget
func (b *Button) CreateRenderer() fyne.WidgetRenderer <span class="cov8" title="1">{
        return widget.NewSimpleRenderer(b.Label)
}</span>

// Left click action
func (b *Button) Tapped(_ *fyne.PointEvent) <span class="cov8" title="1">{
        b.Action()
}</span>

// Right click action, currently not implemented or exposed
func (b *Button) TappedSecondary(_ *fyne.PointEvent) {<span class="cov0" title="0">}</span>

// Set label text to the given string and refresh widget
func (b *Button) SetText(text string) <span class="cov8" title="1">{
        b.Label.Text = text
        b.Refresh()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "strconv"

        "fyne.io/fyne/v2/canvas"
)

// Displays a counter that can be increased and decreased
type Counter struct {
        Label *canvas.Text
        Count int
}

// Create new counter
func NewCounter(count int) *Counter <span class="cov8" title="1">{
        return &amp;Counter{
                Label: newGridLabel(strconv.Itoa(count)),
                Count: count,
        }
}</span>

// Set the count to a specific number
func (m *Counter) SetCount(c int) <span class="cov8" title="1">{
        m.Count = c
        m.refresh()
}</span>

// Redraw the counter from the current count
func (m *Counter) refresh() <span class="cov8" title="1">{
        if m.Count &lt; 0 </span><span class="cov8" title="1">{
                m.Label.Text = "0"
        }</span> else<span class="cov8" title="1"> {
                m.Label.Text = strconv.Itoa(m.Count)
        }</span>
        <span class="cov8" title="1">m.Label.Refresh()</span>
}

// Increase the counter
func (m *Counter) Inc() <span class="cov8" title="1">{
        m.Count++
        m.refresh()
}</span>

// Decrease the counter
func (m *Counter) Dec() <span class="cov8" title="1">{
        m.Count--
        m.refresh()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "image/color"
        "log"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

var (
        GridLabelColor = color.RGBA{240, 10, 20, alpha}
)

const (
        GridLabelSize float32 = 40

        ResetDefaultText          = "🙂"
        ResetGameOverText         = "☠"
        ResetGameWonText          = "😎"
        ResetTextSize     float32 = 40
)

// Graphical display for a minesweeper game
type MinesweeperGrid struct {
        Tiles      [][]*Tile
        Difficulty minesweeper.Difficulty
        Game       minesweeper.Game

        Timer       *Timer
        MineCount   *Counter
        ResetButton *Button
}

// Create a new grid suitable for the give difficulty
func NewMinesweeperGrid(d minesweeper.Difficulty) *MinesweeperGrid <span class="cov8" title="1">{
        tiles := utils.Make2D[*Tile](d.Row, d.Col)
        grid := &amp;MinesweeperGrid{
                Tiles:      tiles,
                Difficulty: d,
                Timer:      NewTimer(),
                MineCount:  NewCounter(d.Mines),
        }
        grid.ResetButton = NewButton(ResetDefaultText, color.RGBA{}, grid.NewGame)
        grid.ResetButton.Label.TextSize = ResetTextSize

        for x := 0; x &lt; grid.Row(); x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; grid.Col(); y++ </span><span class="cov8" title="1">{
                        grid.Tiles[x][y] = NewTile(x, y, grid)
                }</span>
        }

        <span class="cov8" title="1">return grid</span>
}

// Get the graphical representation of the grid
func (g *MinesweeperGrid) GetCanvasObject() fyne.CanvasObject <span class="cov8" title="1">{
        mineCount := container.NewHBox(layout.NewSpacer(), container.NewCenter(newBorder(g.MineCount.Label)))
        reset := container.NewCenter(g.ResetButton)
        timer := container.NewHBox(container.NewCenter(newBorder(g.Timer.Label)), layout.NewSpacer())

        head := newBorder(container.NewGridWithColumns(3, mineCount, reset, timer))

        rows := make([]fyne.CanvasObject, len(g.Tiles))

        for x := 0; x &lt; g.Row(); x++ </span><span class="cov8" title="1">{
                col := make([]fyne.CanvasObject, g.Col())
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov8" title="1">{
                        col[y] = g.Tiles[x][y]
                }</span>
                <span class="cov8" title="1">rows[x] = container.NewGridWithColumns(g.Col(), col...)</span>
        }
        <span class="cov8" title="1">body := newBorder(container.NewGridWithRows(g.Row(), rows...))
        return container.NewVBox(head, body)</span>
}

// Called by the child tiles to signal they have been tapped.
// Checks the given tile and then updates the display according to the new state.
// Starts a new game when no game is currently running.
func (g *MinesweeperGrid) TappedTile(pos minesweeper.Pos) <span class="cov8" title="1">{
        if g.Game == nil </span><span class="cov8" title="1">{
                g.Game = minesweeper.NewGameWithSafePos(g.Difficulty, pos)
        }</span>
        <span class="cov8" title="1">if !g.Timer.Running() </span><span class="cov8" title="1">{
                g.Timer.Start()
        }</span>

        <span class="cov8" title="1">log.Printf("Checking field (%d, %d)\n", pos.X, pos.Y)

        s := g.Game.CheckField(pos)
        log.Println("Checked field, updating tiles")
        g.updateFromStatus(s)</span>
}

// Update the grid from the given status
func (g *MinesweeperGrid) updateFromStatus(s *minesweeper.Status) <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if s.GameOver || s.GameWon </span><span class="cov8" title="1">{
                switch </span>{
                case s.GameWon:<span class="cov8" title="1">
                        log.Println("Win")
                        g.ResetButton.SetText(ResetGameWonText)</span>
                case s.GameOver:<span class="cov8" title="1">
                        log.Println("Game Over")
                        g.ResetButton.SetText(ResetGameOverText)</span>
                }
                <span class="cov8" title="1">g.Timer.Stop()</span>
        }

        <span class="cov8" title="1">for x := 0; x &lt; g.Row(); x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov8" title="1">{
                        t := g.Tiles[x][y]
                        if s.Field[x][y].Content == minesweeper.Unknown </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">t.Field = &amp;s.Field[x][y]
                        t.UpdateContent()</span>
                }
        }
        <span class="cov8" title="1">log.Println("Finished Update")</span>
}

// Return the number of rows in the grid
func (g *MinesweeperGrid) Row() int <span class="cov8" title="1">{
        return g.Difficulty.Row
}</span>

// Return the number of columns in the grid
func (g *MinesweeperGrid) Col() int <span class="cov8" title="1">{
        return g.Difficulty.Col
}</span>

// Start a new game
func (g *MinesweeperGrid) NewGame() <span class="cov8" title="1">{
        log.Println("Preparing for new game")
        g.Game = nil
        g.Reset()
}</span>

// Replay the current game
func (g *MinesweeperGrid) Replay() <span class="cov8" title="1">{
        log.Println("Preparing for replay of current game")
        if g.Game != nil </span><span class="cov8" title="1">{
                g.Game.Replay()
        }</span>
        <span class="cov8" title="1">g.Reset()</span>
}

// Reset Grid
func (g *MinesweeperGrid) Reset() <span class="cov8" title="1">{
        for x := 0; x &lt; g.Row(); x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov8" title="1">{
                        g.Tiles[x][y].Reset()
                }</span>
        }
        <span class="cov8" title="1">g.MineCount.SetCount(g.Difficulty.Mines)
        g.Timer.Reset()
        g.ResetButton.SetText(ResetDefaultText)
        g.ResetButton.Refresh()
        log.Println("Reset grid")</span>
}

// Check if the given position is out of bounds.
// Calls Game.OutOfBounds(Pos)
func (g *MinesweeperGrid) OutOfBounds(p minesweeper.Pos) bool <span class="cov8" title="1">{
        return g.Game.OutOfBounds(p)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "image/color"
        "strconv"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/assets"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var (
        TileDefaultColor    = color.Gray16{32767}
        TileBackgroundColor = color.Gray16{^uint16(0)}
        TileExplodedColor   = color.RGBA{240, 10, 20, alpha}

        TileSize             = fyne.NewSize(32, 32)
        TileTextSize float32 = 23 // Biggest we can go with TileSize of 32^2
)

const alpha = ^uint8(0)

var TileTextColor = []color.Color{
        color.White,
        color.RGBA{20, 15, 220, alpha},  // 1, blue
        color.RGBA{5, 110, 20, alpha},   // 2, green
        color.RGBA{240, 10, 20, alpha},  // 3, red
        color.RGBA{5, 5, 100, alpha},    // 4, dark blue
        color.RGBA{90, 38, 42, alpha},   // 5, brown
        color.RGBA{25, 230, 230, alpha}, // 6, cyan
        color.RGBA{10, 10, 10, alpha},   // 7, black
        color.RGBA{64, 64, 64, alpha},   // 8, grey
}

// A tile extends the base widget and displays the current state of the backing games field
type Tile struct {
        widget.BaseWidget

        background *canvas.Rectangle
        label      *canvas.Text
        icon       *widget.Icon

        Pos     minesweeper.Pos
        Field   *minesweeper.Field
        grid    *MinesweeperGrid
        Flagged bool
}

// Create a new Tile with a reference to it's parent grid, as well as knowledge of it's own position in the Grid
func NewTile(x, y int, grid *MinesweeperGrid) *Tile <span class="cov8" title="1">{
        t := &amp;Tile{
                Pos: minesweeper.NewPos(x, y),
                Field: &amp;minesweeper.Field{
                        Checked: false,
                        Content: minesweeper.Unknown,
                },
                grid: grid,
        }
        t.ExtendBaseWidget(t)

        return t
}</span>

// Function to create renderer needed to implement widget
func (t *Tile) CreateRenderer() fyne.WidgetRenderer <span class="cov8" title="1">{
        t.ExtendBaseWidget(t)

        t.background = canvas.NewRectangle(TileDefaultColor)
        t.background.SetMinSize(TileSize)

        t.label = canvas.NewText("", color.White)
        t.label.TextStyle.Bold = true
        t.label.Alignment = fyne.TextAlignCenter
        t.label.TextSize = TileTextSize
        t.label.Hidden = true

        t.icon = widget.NewIcon(nil)
        t.icon.Resize(TileSize)
        t.icon.Hidden = true

        content := container.NewStack(t.background, t.icon, t.label)
        return widget.NewSimpleRenderer(content)
}</span>

// Left mouse click on tile
func (t *Tile) Tapped(_ *fyne.PointEvent) <span class="cov8" title="1">{
        if t.untappable() || t.Flagged </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.grid.TappedTile(t.Pos)</span>
}

// Right mouse click on tile
func (t *Tile) TappedSecondary(_ *fyne.PointEvent) <span class="cov8" title="1">{
        if t.untappable() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if t.Flagged </span><span class="cov8" title="1">{
                t.grid.MineCount.Inc()
        }</span> else<span class="cov8" title="1"> {
                t.grid.MineCount.Dec()
        }</span>
        <span class="cov8" title="1">t.Flagged = !t.Flagged
        t.UpdateContent()</span>
}

// Double click on tile
func (t *Tile) DoubleTapped(_ *fyne.PointEvent) <span class="cov8" title="1">{
        if !t.Field.Checked || t.gameFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var status *minesweeper.Status
        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        p := t.Pos
                        p.X += m
                        p.Y += n
                        if !t.grid.OutOfBounds(p) </span><span class="cov8" title="1">{
                                if t.grid.Tiles[p.X][p.Y].untappable() || t.grid.Tiles[p.X][p.Y].Flagged </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">status = t.grid.Game.CheckField(p)</span>
                        }
                }
        }
        <span class="cov8" title="1">t.grid.updateFromStatus(status)</span>
}

// Update the tile render depending on the current state of it's backing Field
func (t *Tile) UpdateContent() <span class="cov8" title="1">{
        t.icon.Hidden = true
        t.label.Hidden = true
        defer t.Refresh()
        if t.Flagged &amp;&amp; !t.Field.Checked </span><span class="cov8" title="1">{
                t.icon.SetResource(assets.ResourceFlagPng)
                t.icon.Hidden = false
                return
        }</span>
        <span class="cov8" title="1">if t.Field.Checked </span><span class="cov8" title="1">{
                t.background.FillColor = TileBackgroundColor
        }</span> else<span class="cov8" title="1"> {
                t.background.FillColor = TileDefaultColor
        }</span>
        <span class="cov8" title="1">if t.Field.Content == minesweeper.Unknown </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if t.Field.Content == minesweeper.Mine </span><span class="cov8" title="1">{
                t.icon.SetResource(assets.ResourceMinePng)
                t.icon.Hidden = false
                if t.Field.Checked </span><span class="cov8" title="1">{
                        t.background.FillColor = TileExplodedColor
                }</span>
        }
        <span class="cov8" title="1">if t.Field.Checked &amp;&amp; t.Field.Content &gt; 0 &amp;&amp; t.Field.Content &lt; 9 </span><span class="cov8" title="1">{
                t.label.Text = strconv.Itoa(int(t.Field.Content))
                t.label.Color = TileTextColor[t.Field.Content]
                t.label.Hidden = false
        }</span>
}

// Reset tile to default state, used for starting new game
func (t *Tile) Reset() <span class="cov8" title="1">{
        t.Flagged = false
        t.Field.Checked = false
        t.Field.Content = minesweeper.Unknown
        t.UpdateContent()
}</span>

// Check if the tile should be clickable
func (t *Tile) untappable() bool <span class="cov8" title="1">{
        return t.Field.Checked || t.gameFinished()
}</span>

// Check if game is finished
func (t *Tile) gameFinished() bool <span class="cov8" title="1">{
        if t.grid.Game != nil </span><span class="cov8" title="1">{
                return t.grid.Game.Lost() || t.grid.Game.Won()
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "fmt"
        "log"
        "time"

        "fyne.io/fyne/v2/canvas"
)

// Timer to display an upwards countdown in a fyne app.
type Timer struct {
        Label   *canvas.Text
        Seconds int
        stop    chan bool
        running bool
}

// Create new timer
func NewTimer() *Timer <span class="cov8" title="1">{
        return &amp;Timer{
                Label:   newGridLabel("0000"),
                Seconds: 0,
                stop:    make(chan bool),
        }
}</span>

// Start the timer, runs concurrently
func (t *Timer) Start() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Second)
        t.running = true
        go func() </span><span class="cov8" title="1">{
                log.Println("Started timer")
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-t.stop:<span class="cov8" title="1">
                                ticker.Stop()
                                log.Printf("Stopped timer after %d seconds\n", t.Seconds)
                                return</span>
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                t.Seconds++
                                t.refresh()</span>
                        }
                }
        }()
}

// Stop the timer
func (t *Timer) Stop() <span class="cov8" title="1">{
        if t.Running() </span><span class="cov8" title="1">{
                t.stop &lt;- true
                t.running = false
        }</span>
}

// Reset the timer back to zero
func (t *Timer) Reset() <span class="cov8" title="1">{
        t.Stop()
        t.Seconds = 0
        t.refresh()
}</span>

// Check if the timer is running
func (t *Timer) Running() bool <span class="cov8" title="1">{
        return t.running
}</span>

// Refresh the timer from it's current values
func (t *Timer) refresh() <span class="cov8" title="1">{
        t.Label.Text = fmt.Sprintf("%04d", t.Seconds)
        t.Label.Refresh()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "image/color"
        "os"
        "path/filepath"
        "runtime"
        "runtime/debug"
        "strings"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
)

// Struct for containing the current version of the app
type Version struct {
        Name, Version, Commit, Go string
}

// Extract the version information from app
func getVersion(app fyne.App) Version <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov0" title="0">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span>

        <span class="cov8" title="1">metadata := app.Metadata()

        name, _ := strings.CutSuffix(metadata.Name, ".exe")
        if name == "" </span><span class="cov8" title="1">{
                name = filepath.Base(os.Args[0])
        }</span>

        <span class="cov8" title="1">return Version{
                Name:    name,
                Version: "v" + metadata.Version,
                Commit:  commit,
                Go:      runtime.Version(),
        }</span>
}

// Create the content for the version dialog
func getVersionContent(v Version) fyne.CanvasObject <span class="cov0" title="0">{
        r1 := make([]fyne.CanvasObject, 3)
        r2 := make([]fyne.CanvasObject, 3)
        r1[0] = canvas.NewText("Version:", TEXT_COLOR)
        r2[0] = canvas.NewText(v.Version, TEXT_COLOR)
        r1[1] = canvas.NewText("Commit:", TEXT_COLOR)
        r2[1] = canvas.NewText(v.Commit, TEXT_COLOR)
        r1[2] = canvas.NewText("Go:", TEXT_COLOR)
        r2[2] = canvas.NewText(v.Go, TEXT_COLOR)

        row1 := container.NewVBox(r1...)
        row2 := container.NewVBox(r2...)

        return container.NewPadded(container.NewHBox(row1, row2))
}</span>

// Create a line for the border
func makeBorderStrip() fyne.CanvasObject <span class="cov8" title="1">{
        rec := canvas.NewRectangle(color.White)
        rec.SetMinSize(fyne.NewSize(1, 1))
        return rec
}</span>

// Wrap the objects in a box with border lines
func newBorder(content ...fyne.CanvasObject) fyne.CanvasObject <span class="cov8" title="1">{
        top := makeBorderStrip()
        left := makeBorderStrip()
        bottom := makeBorderStrip()
        right := makeBorderStrip()
        border := container.NewBorder(top, bottom, left, right, content...)
        return container.NewPadded(border)
}</span>

// Create a new label used in the grid, with preset color, text size and text style
func newGridLabel(text string) *canvas.Text <span class="cov8" title="1">{
        label := canvas.NewText(text, GridLabelColor)
        label.TextSize = GridLabelSize
        label.TextStyle.Bold = true
        return label
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package minesweeper

const (
        DifficultyClassic      = iota
        DifficultyBeginner     = iota
        DifficultyIntermediate = iota
        DifficultyExpert       = iota
)

const (
        DifficultyRowColMin         = 8
        DifficultyRowColMax         = 99
        DifficultyMineMin           = 9
        DifficultyMineMaxPercentage = 0.8
)

// Represent a difficulty setting for the Game
type Difficulty struct {
        Name     string
        Row, Col int
        Mines    int
}

// Pre-defined difficulties
var difficulties []Difficulty = []Difficulty{
        {
                Name:  "Classic",
                Row:   8,
                Col:   8,
                Mines: 9,
        },
        {
                Name:  "Beginner",
                Row:   9,
                Col:   9,
                Mines: 10,
        },
        {
                Name:  "Intermediate",
                Row:   16,
                Col:   16,
                Mines: 40,
        },
        {
                Name:  "Expert",
                Row:   16,
                Col:   30,
                Mines: 99,
        },
}

// Exposes pre-defined difficulties in a way that does not allow the original array to be modified
func Difficulties() []Difficulty <span class="cov8" title="1">{
        list := make([]Difficulty, len(difficulties))
        copy(list, difficulties)
        return list
}</span>

func NewCustomDifficulty(mines, row, col int) (Difficulty, error) <span class="cov8" title="1">{
        if row &lt; DifficultyRowColMin || row &gt; DifficultyRowColMax || col &lt; DifficultyRowColMin || col &gt; DifficultyRowColMax </span><span class="cov8" title="1">{
                return Difficulty{}, NewErrDifficultyDimension(row, col)
        }</span>
        <span class="cov8" title="1">if mines &lt; DifficultyMineMin || float64(mines) &gt; float64(row*col)*DifficultyMineMaxPercentage </span><span class="cov8" title="1">{
                return Difficulty{}, NewErrDifficultyMineCount(mines)
        }</span>
        <span class="cov8" title="1">return Difficulty{
                Name:  "Custom",
                Row:   row,
                Col:   col,
                Mines: mines,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package minesweeper

import "fmt"

type ErrDifficultyDimension struct {
        row int
        col int
}

func NewErrDifficultyDimension(row, col int) error <span class="cov8" title="1">{
        return &amp;ErrDifficultyDimension{row, col}
}</span>

func (e *ErrDifficultyDimension) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Rows and Columns need to be between %d and %d, got %dx%d", DifficultyRowColMin, DifficultyRowColMax, e.row, e.col)
}</span>

type ErrDifficultyMineCount struct {
        mines int
}

func NewErrDifficultyMineCount(mines int) error <span class="cov8" title="1">{
        return &amp;ErrDifficultyMineCount{mines}
}</span>

func (e *ErrDifficultyMineCount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("The number of mines need to be between %d and %.1f %% of the total number of cells, got %d", DifficultyMineMin, DifficultyMineMaxPercentage*100, e.mines)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package minesweeper

import (
        "log"

        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

// Represents the content of a field.
// Can be a mine, unknown or the number of mines in the neighboring fields
type FieldContent int

const (
        Mine    FieldContent = -1
        Unknown FieldContent = -2
)

// Represents a single field in a minefield
type Field struct {
        Checked bool
        Content FieldContent
}

// Status contains the current state of the game known to the player.
// As such it will always be a copy and needs to be it's own type, despite the
// overlapping similarities.
// It does not support any of the functions that Game does.
// It is safe to write to Status, as it is merely a copy.
type Status struct {
        Field    [][]Field
        GameOver bool
        GameWon  bool
}

// Interface for playing the game
type Game interface {
        // Check a given field and recursevly reveal all neighboring fields that should be revield.
        // Returns the resulting new status of the game
        CheckField(p Pos) *Status
        // Recursive function to reveal all neighbouring fields that can be safely reveald.
        // Stops when a field has not exactly zero neighbouring mines
        RevealField(p Pos)
        // Check if the given position is out of bounds
        OutOfBounds(p Pos) bool
        // Returns the current status of the game. Only contains the knowledge a player should have.
        Status() *Status
        // Check if Game Over
        Lost() bool
        // Check if the game is won
        Won() bool
        // Reset the current game to be played again
        Replay()
        // Check if the game is a replay
        IsReplay() bool
}

type LocalGame struct {
        Field      [][]Field
        Difficulty Difficulty

        // Keep these 2 exported for testing in other packages
        GameOver bool
        GameWon  bool

        replay bool
}

// Create a new game with mines seeded randomly in the map, with the exception of the given position.
func NewGameWithSafePos(d Difficulty, p Pos) *LocalGame <span class="cov8" title="1">{
        g := &amp;LocalGame{
                Field:      utils.Make2D[Field](d.Row, d.Col),
                Difficulty: d,
                GameOver:   false,
                GameWon:    false,
        }

        mines := CreateMines(d, p)
        for _, mine := range mines </span><span class="cov8" title="1">{
                g.Field[mine.X][mine.Y].Content = Mine
        }</span>

        <span class="cov8" title="1">g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                if g.Field[x][y].Content == Mine </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">g.Field[x][y].Content = FieldContent(g.countNearbyMines(NewPos(x, y)))</span>
        })

        <span class="cov8" title="1">return g</span>
}

// Check a given field and recursevly reveal all neighboring fields that should be revield.
// Returns the resulting new status of the game
func (g *LocalGame) CheckField(p Pos) *Status <span class="cov8" title="1">{
        if g.Lost() || g.Won() </span><span class="cov8" title="1">{
                return g.Status()
        }</span>

        <span class="cov8" title="1">g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content == Mine </span><span class="cov8" title="1">{
                g.GameOver = true
                return g.Status()
        }</span>

        <span class="cov8" title="1">g.RevealField(p)

        return g.Status()</span>
}

// Recursive function to reveal all neighbouring fields that can be safely reveald.
// Stops when a field has not exactly zero neighbouring mines
func (g *LocalGame) RevealField(p Pos) <span class="cov8" title="1">{
        log.Printf("Reveal tile (%d, %d), content: %d\n", p.X, p.Y, g.Field[p.X][p.Y].Content)

        g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content != 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Revealing neigbhours of (%d, %d)\n", p.X, p.Y)

        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        if m == 0 &amp;&amp; n == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">i := NewPos(p.X+m, p.Y+n)
                        if g.OutOfBounds(i) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if !g.Field[i.X][i.Y].Checked </span><span class="cov8" title="1">{
                                g.RevealField(i)
                        }</span>
                }
        }
}

// Check if the given position is out of bounds
func (g *LocalGame) OutOfBounds(p Pos) bool <span class="cov8" title="1">{
        d := g.Difficulty
        return p.X &lt; 0 || p.X &gt; d.Row-1 || p.Y &lt; 0 || p.Y &gt; d.Col-1
}</span>

// Returns the current status of the game. Only contains the knowledge a player should have.
func (g *LocalGame) Status() *Status <span class="cov8" title="1">{
        d := g.Difficulty
        s := &amp;Status{
                Field:    utils.Make2D[Field](d.Row, d.Col),
                GameOver: g.Lost(),
                GameWon:  g.Won(),
        }

        wasWon := g.Won()
        isWon := true

        g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                s.Field[x][y].Checked = g.Field[x][y].Checked
                if g.Field[x][y].Checked || g.Lost() || g.Won() </span><span class="cov8" title="1">{
                        s.Field[x][y].Content = g.Field[x][y].Content
                }</span> else<span class="cov8" title="1"> {
                        s.Field[x][y].Content = Unknown
                }</span>
                <span class="cov8" title="1">if !g.Field[x][y].Checked &amp;&amp; g.Field[x][y].Content != Mine </span><span class="cov8" title="1">{
                        isWon = false
                }</span>
        })

        <span class="cov8" title="1">if !wasWon &amp;&amp; isWon </span><span class="cov8" title="1">{
                g.GameWon, s.GameWon = isWon, isWon
                for x := 0; x &lt; d.Row; x++ </span><span class="cov8" title="1">{
                        copy(s.Field[x], g.Field[x])
                }</span>
        }

        <span class="cov8" title="1">return s</span>
}

// Check if Game Over
func (g *LocalGame) Lost() bool <span class="cov8" title="1">{
        return g.GameOver
}</span>

// Check if the game is won
func (g *LocalGame) Won() bool <span class="cov8" title="1">{
        return g.GameWon
}</span>

// Reset the current game to be played again
func (g *LocalGame) Replay() <span class="cov8" title="1">{
        g.replay = true
        g.GameOver = false
        g.GameWon = false

        g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                g.Field[x][y].Checked = false
        }</span>)
}

// Check if the game is a replay
func (g *LocalGame) IsReplay() bool <span class="cov8" title="1">{
        return g.replay
}</span>

// Walk through all fields of the game and call the given function
func (g *LocalGame) walkField(f func(x, y int)) <span class="cov8" title="1">{
        d := g.Difficulty
        for x := 0; x &lt; d.Row; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; d.Col; y++ </span><span class="cov8" title="1">{
                        f(x, y)
                }</span>
        }
}

// Count the the number of mines in the neighboring fields
func (g *LocalGame) countNearbyMines(p Pos) int <span class="cov8" title="1">{
        c := 0
        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        if g.OutOfBounds(NewPos(p.X+m, p.Y+n)) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if g.Field[p.X+m][p.Y+n].Content == Mine </span><span class="cov8" title="1">{
                                c++
                        }</span>
                }
        }
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package minesweeper

import (
        "fmt"
        "math/rand"
        "slices"
)

// Represent a position in the minefield
type Pos struct {
        X, Y int
}

// Create a new Position from the given coordinates
func NewPos(x, y int) Pos <span class="cov8" title="1">{
        return Pos{x, y}
}</span>

// Returns a random position inside the provided limits
func RandomPos(maxX, maxY int) Pos <span class="cov8" title="1">{
        return NewPos(rand.Intn(maxX), rand.Intn(maxY))
}</span>

// Returns a string representation of the position
func (p Pos) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}</span>

// Randomly create mines for the given difficulty.
// Does not create a mine on the given position.
func CreateMines(d Difficulty, p Pos) []Pos <span class="cov8" title="1">{
        mines := make([]Pos, 0, d.Mines+1)

        mines = append(mines, p)
        for i := 0; i &lt; d.Mines; i++ </span><span class="cov8" title="1">{
                p = RandomPos(d.Row, d.Col)
                for slices.Contains(mines, p) </span><span class="cov8" title="1">{
                        p = RandomPos(d.Row, d.Col)
                }</span>
                <span class="cov8" title="1">mines = append(mines, p)</span>
        }
        <span class="cov8" title="1">return mines[1:]</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

// Create a new, empty 2 dimensional array of the given type and dimensions.
func Make2D[T any](x, y int) [][]T <span class="cov8" title="1">{
        if x &lt; 1 || y &lt; 1 </span><span class="cov8" title="1">{
                return [][]T{}
        }</span>

        <span class="cov8" title="1">matrix := make([][]T, x)
        rows := make([]T, x*y)

        for i := 0; i &lt; x; i++ </span><span class="cov8" title="1">{
                matrix[i] = rows[i*y : (i+1)*y]
        }</span>
        <span class="cov8" title="1">return matrix</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
