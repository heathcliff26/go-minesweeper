
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/go-minesweeper/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/go-minesweeper/cmd/log-parser/main.go (0.0%)</option>
				
				<option value="file2">github.com/heathcliff26/go-minesweeper/pkg/app/app.go (45.9%)</option>
				
				<option value="file3">github.com/heathcliff26/go-minesweeper/pkg/app/button.go (100.0%)</option>
				
				<option value="file4">github.com/heathcliff26/go-minesweeper/pkg/app/counter.go (100.0%)</option>
				
				<option value="file5">github.com/heathcliff26/go-minesweeper/pkg/app/grid.go (99.0%)</option>
				
				<option value="file6">github.com/heathcliff26/go-minesweeper/pkg/app/log.go (100.0%)</option>
				
				<option value="file7">github.com/heathcliff26/go-minesweeper/pkg/app/tile.go (100.0%)</option>
				
				<option value="file8">github.com/heathcliff26/go-minesweeper/pkg/app/timer.go (100.0%)</option>
				
				<option value="file9">github.com/heathcliff26/go-minesweeper/pkg/app/utils.go (43.1%)</option>
				
				<option value="file10">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/difficulty.go (100.0%)</option>
				
				<option value="file11">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/errors.go (50.0%)</option>
				
				<option value="file12">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/game.go (100.0%)</option>
				
				<option value="file13">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/save.go (84.6%)</option>
				
				<option value="file14">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/status.go (100.0%)</option>
				
				<option value="file15">github.com/heathcliff26/go-minesweeper/pkg/minesweeper/utils.go (100.0%)</option>
				
				<option value="file16">github.com/heathcliff26/go-minesweeper/pkg/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/heathcliff26/go-minesweeper/pkg/app"

func main() <span class="cov0" title="0">{
        app := app.New()
        app.Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "flag"
        "fmt"
        "os"
        "regexp"
        "strconv"

        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var input, output string
var usage bool

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;input, "i", "", "Input file")
        flag.StringVar(&amp;output, "o", "", "Output file")
        flag.BoolVar(&amp;usage, "h", false, "Show helptext")
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()
        if usage </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>
        <span class="cov0" title="0">if input == "" </span><span class="cov0" title="0">{
                fmt.Println("You need to specify an input file with -i &lt;file&gt;")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if output == "" </span><span class="cov0" title="0">{
                fmt.Println("You need to specify an output file with -o &lt;file&gt;")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">f, err := os.ReadFile(input)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">reg := regexp.MustCompile(`time=.* level=INFO msg="Checking field" pos="\((\d*), (\d*)\)"\n`)

        positions := reg.FindAllStringSubmatch(string(f), -1)
        p := make([]minesweeper.Pos, len(positions))
        for i, pos := range positions </span><span class="cov0" title="0">{
                x, err := strconv.Atoi(pos[1])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">y, err := strconv.Atoi(pos[2])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">p[i] = minesweeper.NewPos(x, y)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Found %d positions in log\n", len(p))

        buf, err := json.MarshalIndent(p, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(output, buf, 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println("Success!!!")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "image/color"
        "os"

        "fyne.io/fyne/v2"
        fApp "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/data/binding"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/storage"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var TEXT_COLOR = color.White

var DEFAULT_DIFFICULTY = minesweeper.Difficulties()[minesweeper.DifficultyIntermediate]

const DEFAULT_GAME_ALGORITHM = GameAlgorithmSafeArea

// Used to change the new app function for testing
var newApp = fApp.New

// Struct representing the current app.
// There should only ever be a single instance during runtime.
type App struct {
        app            fyne.App
        main           fyne.Window
        Version        Version
        grid           *MinesweeperGrid
        difficulties   []*fyne.MenuItem
        gameMenu       []*fyne.MenuItem
        assistedMode   *fyne.MenuItem
        gameAlgorithms []*fyne.MenuItem
}

// Create a new App
func New() *App <span class="cov8" title="1">{
        app := newApp()
        version := getVersion(app)
        main := app.NewWindow(version.Name)

        a := &amp;App{
                app:     app,
                main:    main,
                Version: version,
        }
        a.main.SetTitle(version.Name)
        a.makeMenu()
        a.NewGrid(DEFAULT_DIFFICULTY)
        a.setGameAlgorithm(DEFAULT_GAME_ALGORITHM)

        a.main.SetFixedSize(true)
        a.main.Show()

        return a
}</span>

// Simply calls app.Run()
func (a *App) Run() <span class="cov0" title="0">{
        a.app.Run()
}</span>

// Create the main menu bar
func (a *App) makeMenu() <span class="cov8" title="1">{
        // Can't assign grid functions directly, as the instance of grid may change
        newGameOption := fyne.NewMenuItem("New", func() </span><span class="cov8" title="1">{
                a.grid.NewGame()
        }</span>)
        <span class="cov8" title="1">replayOption := fyne.NewMenuItem("Replay", func() </span><span class="cov8" title="1">{
                a.grid.Replay()
        }</span>)
        <span class="cov8" title="1">loadOption := fyne.NewMenuItem("Load", a.loadSave)
        saveOption := fyne.NewMenuItem("Save", a.saveGame)
        a.gameMenu = []*fyne.MenuItem{newGameOption, replayOption, fyne.NewMenuItemSeparator(), loadOption, saveOption}
        gameMenu := fyne.NewMenu("Game", a.gameMenu...)

        difficulties := minesweeper.Difficulties()
        diffItems := make([]*fyne.MenuItem, 0, len(difficulties)+2)
        for _, d := range difficulties </span><span class="cov8" title="1">{
                item := fyne.NewMenuItem(d.Name, nil)
                item.Action = func() </span><span class="cov8" title="1">{
                        if item.Checked </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">for _, i := range a.difficulties </span><span class="cov8" title="1">{
                                i.Checked = (i.Label == d.Name)
                        }</span>
                        <span class="cov8" title="1">a.NewGrid(d)</span>
                }
                <span class="cov8" title="1">item.Checked = (d == DEFAULT_DIFFICULTY)
                diffItems = append(diffItems, item)</span>
        }
        <span class="cov8" title="1">diffItems = append(diffItems, fyne.NewMenuItemSeparator())
        diffItems = append(diffItems, fyne.NewMenuItem("Custom", a.customDifficultyDialog))
        a.difficulties = diffItems
        diffMenu := fyne.NewMenu("Difficulties", diffItems...)

        a.assistedMode = fyne.NewMenuItem("      Assisted Mode", func() </span><span class="cov8" title="1">{
                a.assistedMode.Checked = !a.assistedMode.Checked
                a.grid.AssistedMode = a.assistedMode.Checked
                if a.grid.AssistedMode &amp;&amp; a.grid.Game != nil </span><span class="cov0" title="0">{
                        a.grid.updateFromStatus(a.grid.Game.Status())
                }</span>
        })
        <span class="cov8" title="1">a.gameAlgorithms = make([]*fyne.MenuItem, 2)
        a.gameAlgorithms[0] = fyne.NewMenuItem("Safe Position", func() </span><span class="cov8" title="1">{
                a.setGameAlgorithm(GameAlgorithmSafePos)
        }</span>)
        <span class="cov8" title="1">a.gameAlgorithms[1] = fyne.NewMenuItem("Safe Area", func() </span><span class="cov8" title="1">{
                a.setGameAlgorithm(GameAlgorithmSafeArea)
        }</span>)
        <span class="cov8" title="1">gameAlgorithmSubMenu := fyne.NewMenuItem("Creation Algorithm", nil)
        gameAlgorithmSubMenu.ChildMenu = fyne.NewMenu("Creation Algorithm", a.gameAlgorithms...)
        optionsMenu := fyne.NewMenu("Options", a.assistedMode, gameAlgorithmSubMenu)

        hint := fyne.NewMenuItem("Hint", func() </span><span class="cov0" title="0">{
                if !a.grid.Hint() </span><span class="cov0" title="0">{
                        dialog.NewInformation("No hint found", "Could not find any hints to give.", a.main).Show()
                }</span>
        })
        <span class="cov8" title="1">about := fyne.NewMenuItem("About", func() </span><span class="cov0" title="0">{
                vInfo := dialog.NewCustom(a.Version.Name, "close", getVersionContent(a.Version), a.main)
                vInfo.Show()
        }</span>)
        <span class="cov8" title="1">helpMenu := fyne.NewMenu("Help", hint, about)

        a.main.SetMainMenu(fyne.NewMainMenu(gameMenu, diffMenu, optionsMenu, helpMenu))</span>
}

// Update the content of the app and resize the window to make it fit
func (a *App) setContent() <span class="cov8" title="1">{
        content := container.NewPadded(a.grid.GetCanvasObject())
        content.Resize(content.MinSize())

        a.main.SetContent(content)
        a.main.Resize(content.MinSize())
}</span>

// Show a dialog for setting a custom difficulty
func (a *App) customDifficultyDialog() <span class="cov0" title="0">{
        mines := minesweeper.DifficultyMineMin
        row, col := minesweeper.DifficultyRowColMin, minesweeper.DifficultyRowColMin

        mineLabel := canvas.NewText("Mines", TEXT_COLOR)
        mineEntry := widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;mines)))
        rowLabel := canvas.NewText("Rows", TEXT_COLOR)
        rowEntry := widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;row)))
        colLabel := canvas.NewText("Columns", TEXT_COLOR)
        colEntry := widget.NewEntryWithData(binding.IntToString(binding.BindInt(&amp;col)))

        content := container.NewGridWithColumns(2, mineLabel, mineEntry, rowLabel, rowEntry, colLabel, colEntry)
        diffDialog := dialog.NewCustomConfirm("Custom Difficulty", "ok", "cancel", content, func(ok bool) </span><span class="cov0" title="0">{
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">d, err := minesweeper.NewCustomDifficulty(mines, row, col)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">for _, i := range a.difficulties </span><span class="cov0" title="0">{
                        i.Checked = (i.Label == "Custom")
                }</span>
                <span class="cov0" title="0">a.NewGrid(d)</span>
        }, a.main)
        <span class="cov0" title="0">diffDialog.Show()</span>
}

func (a *App) loadSave() <span class="cov0" title="0">{
        d := dialog.NewFileOpen(func(uri fyne.URIReadCloser, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>
                <span class="cov0" title="0">if uri == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">save, err := minesweeper.LoadSave(uri.URI().Path())
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">for _, i := range a.difficulties </span><span class="cov0" title="0">{
                        i.Checked = (i.Label == save.Data.Difficulty.Name)
                }</span>
                <span class="cov0" title="0">a.NewGrid(save.Data.Difficulty)

                a.grid.Game = save.Game()</span>
        }, a.main)
        <span class="cov0" title="0">d.SetFilter(storage.NewExtensionFileFilter([]string{minesweeper.SaveFileExtension}))

        if !setDialogLocationToPWD(d, a.main) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.Show()</span>
}

func (a *App) saveGame() <span class="cov0" title="0">{
        if a.grid.Game == nil </span><span class="cov0" title="0">{
                d := dialog.NewInformation("Can't save game", "You need to first start a game before you can save it.", a.main)
                d.Show()
                return
        }</span>
        <span class="cov0" title="0">d := dialog.NewFileSave(func(uri fyne.URIWriteCloser, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>
                <span class="cov0" title="0">if uri == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">path := uri.URI().Path()
                _ = uri.Close()

                err = os.Remove(path)
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">save, err := a.grid.Game.ToSave()
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>

                <span class="cov0" title="0">err = save.Save(uri.URI().Path())
                if err != nil </span><span class="cov0" title="0">{
                        dialog.ShowError(err, a.main)
                        return
                }</span>
        }, a.main)
        <span class="cov0" title="0">d.SetFilter(storage.NewExtensionFileFilter([]string{minesweeper.SaveFileExtension}))

        if !setDialogLocationToPWD(d, a.main) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.Show()</span>
}

func (a *App) NewGrid(d minesweeper.Difficulty) <span class="cov8" title="1">{
        a.grid = NewMinesweeperGrid(d, a.assistedMode.Checked)
        for i, item := range a.gameAlgorithms </span><span class="cov8" title="1">{
                if item.Checked </span><span class="cov8" title="1">{
                        a.grid.GameAlgorithm = i
                }</span>
        }
        <span class="cov8" title="1">a.setContent()</span>
}

func (a *App) setGameAlgorithm(id int) <span class="cov8" title="1">{
        for i, item := range a.gameAlgorithms </span><span class="cov8" title="1">{
                item.Checked = i == id
        }</span>
        <span class="cov8" title="1">a.grid.GameAlgorithm = id</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/widget"
)

// Custom implementation for a button that is only portraied by text.
// The text is fully configurable by exposing the backing label.
type Button struct {
        widget.BaseWidget

        Label  *canvas.Text
        Action func()
}

// Create a new button from the given text, color and function
func NewButton(text string, color color.Color, action func()) *Button <span class="cov8" title="1">{
        b := &amp;Button{
                Label:  canvas.NewText(text, color),
                Action: action,
        }
        b.ExtendBaseWidget(b)
        return b
}</span>

// Function to create renderer needed to implement widget
func (b *Button) CreateRenderer() fyne.WidgetRenderer <span class="cov8" title="1">{
        return widget.NewSimpleRenderer(b.Label)
}</span>

// Left click action
func (b *Button) Tapped(_ *fyne.PointEvent) <span class="cov8" title="1">{
        b.Action()
}</span>

// Right click action, currently not implemented or exposed
func (b *Button) TappedSecondary(_ *fyne.PointEvent) {<span class="cov0" title="0">}</span>

// Set label text to the given string and refresh widget
func (b *Button) SetText(text string) <span class="cov8" title="1">{
        b.Label.Text = text
        b.Refresh()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "fmt"
        "strconv"

        "fyne.io/fyne/v2/canvas"
)

// Displays a counter that can be increased and decreased
type Counter struct {
        Label *canvas.Text
        Count int
}

// Create new counter
func NewCounter(count int) *Counter <span class="cov8" title="1">{
        return &amp;Counter{
                Label: newGridLabel(strconv.Itoa(count)),
                Count: count,
        }
}</span>

// Set the count to a specific number
func (m *Counter) SetCount(c int) <span class="cov8" title="1">{
        m.Count = c
        m.refresh()
}</span>

// Redraw the counter from the current count
func (m *Counter) refresh() <span class="cov8" title="1">{
        if m.Count &lt; 0 </span><span class="cov8" title="1">{
                m.Label.Text = "00"
        }</span> else<span class="cov8" title="1"> {
                m.Label.Text = fmt.Sprintf("%02d", m.Count)
        }</span>
        <span class="cov8" title="1">m.Label.Refresh()</span>
}

// Increase the counter
func (m *Counter) Inc() <span class="cov8" title="1">{
        m.Count++
        m.refresh()
}</span>

// Decrease the counter
func (m *Counter) Dec() <span class="cov8" title="1">{
        m.Count--
        m.refresh()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "image/color"
        "log/slog"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

var (
        GridLabelColor = color.RGBA{240, 10, 20, alpha}
)

const (
        GridLabelSize float32 = 40

        ResetDefaultText          = "🙂"
        ResetGameOverText         = "☠"
        ResetGameWonText          = "😎"
        ResetTextSize     float32 = 40
)

const (
        GameAlgorithmSafePos = iota
        GameAlgorithmSafeArea
)

// Graphical display for a minesweeper game
type MinesweeperGrid struct {
        Tiles         [][]*Tile
        Difficulty    minesweeper.Difficulty
        Game          minesweeper.Game
        AssistedMode  bool
        GameAlgorithm int

        Timer       *Timer
        MineCount   *Counter
        ResetButton *Button
}

// Create a new grid suitable for the give difficulty
func NewMinesweeperGrid(d minesweeper.Difficulty, assistedMode bool) *MinesweeperGrid <span class="cov8" title="1">{
        tiles := utils.Make2D[*Tile](d.Row, d.Col)
        grid := &amp;MinesweeperGrid{
                Tiles:         tiles,
                Difficulty:    d,
                AssistedMode:  assistedMode,
                GameAlgorithm: DEFAULT_GAME_ALGORITHM,
                Timer:         NewTimer(),
                MineCount:     NewCounter(d.Mines),
        }
        grid.ResetButton = NewButton(ResetDefaultText, color.RGBA{}, grid.NewGame)
        grid.ResetButton.Label.TextSize = ResetTextSize

        for x := 0; x &lt; grid.Row(); x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; grid.Col(); y++ </span><span class="cov8" title="1">{
                        grid.Tiles[x][y] = NewTile(x, y, grid)
                }</span>
        }

        <span class="cov8" title="1">return grid</span>
}

// Get the graphical representation of the grid
func (g *MinesweeperGrid) GetCanvasObject() fyne.CanvasObject <span class="cov8" title="1">{
        mineCount := container.NewHBox(layout.NewSpacer(), container.NewCenter(newBorder(g.MineCount.Label)))
        reset := container.NewCenter(g.ResetButton)
        timer := container.NewHBox(container.NewCenter(newBorder(g.Timer.Label)), layout.NewSpacer())

        head := newBorder(container.NewGridWithColumns(3, mineCount, reset, timer))

        rows := make([]fyne.CanvasObject, len(g.Tiles))

        for x := 0; x &lt; g.Row(); x++ </span><span class="cov8" title="1">{
                col := make([]fyne.CanvasObject, g.Col())
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov8" title="1">{
                        col[y] = g.Tiles[x][y]
                }</span>
                <span class="cov8" title="1">rows[x] = container.NewGridWithColumns(g.Col(), col...)</span>
        }
        <span class="cov8" title="1">body := newBorder(container.NewGridWithRows(g.Row(), rows...))
        return container.NewVBox(head, body)</span>
}

// Called by the child tiles to signal they have been tapped.
// Checks the given tile and then updates the display according to the new state.
// Starts a new game when no game is currently running.
func (g *MinesweeperGrid) TappedTile(pos minesweeper.Pos) <span class="cov8" title="1">{
        if g.Game == nil </span><span class="cov8" title="1">{
                switch g.GameAlgorithm </span>{
                case GameAlgorithmSafePos:<span class="cov8" title="1">
                        g.Game = minesweeper.NewGameWithSafePos(g.Difficulty, pos)</span>
                case GameAlgorithmSafeArea:<span class="cov8" title="1">
                        g.Game = minesweeper.NewGameWithSafeArea(g.Difficulty, pos)</span>
                default:<span class="cov8" title="1">
                        slog.Error("Unkown Algorithm for creating a new game", slog.Int("algorithm", g.GameAlgorithm))
                        return</span>
                }
        }
        <span class="cov8" title="1">if !g.Timer.Running() </span><span class="cov8" title="1">{
                g.Timer.Start()
        }</span>

        <span class="cov8" title="1">slog.Debug("Checking field", slog.String("pos", pos.String()))

        s := g.Game.CheckField(pos)
        slog.Debug("Checked field, updating tiles")
        g.updateFromStatus(s)</span>
}

// Update the grid from the given status
func (g *MinesweeperGrid) updateFromStatus(s *minesweeper.Status) <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if s.GameOver || s.GameWon </span><span class="cov8" title="1">{
                switch </span>{
                case s.GameWon:<span class="cov8" title="1">
                        slog.Info("Win")
                        g.ResetButton.SetText(ResetGameWonText)</span>
                case s.GameOver:<span class="cov8" title="1">
                        slog.Info("Game Over")
                        g.ResetButton.SetText(ResetGameOverText)</span>
                }
                <span class="cov8" title="1">g.Timer.Stop()</span>
        } else<span class="cov8" title="1"> if g.AssistedMode </span><span class="cov8" title="1">{
                slog.Debug("Creating Markers for Assisted Mode")
                for _, p := range s.ObviousMines() </span><span class="cov8" title="1">{
                        t := g.Tiles[p.X][p.Y]
                        t.Marker = HelpMarkingMine
                        t.UpdateContent()
                }</span>
                <span class="cov8" title="1">for _, p := range s.ObviousSafePos() </span><span class="cov8" title="1">{
                        t := g.Tiles[p.X][p.Y]
                        t.Marker = HelpMarkingSafe
                        t.UpdateContent()
                }</span>
        }

        <span class="cov8" title="1">for x := 0; x &lt; g.Row(); x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov8" title="1">{
                        t := g.Tiles[x][y]
                        if s.Field[x][y].Content == minesweeper.Unknown </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">t.Field = &amp;s.Field[x][y]
                        t.UpdateContent()</span>
                }
        }
        <span class="cov8" title="1">slog.Debug("Finished Update")</span>
}

// Return the number of rows in the grid
func (g *MinesweeperGrid) Row() int <span class="cov8" title="1">{
        return g.Difficulty.Row
}</span>

// Return the number of columns in the grid
func (g *MinesweeperGrid) Col() int <span class="cov8" title="1">{
        return g.Difficulty.Col
}</span>

// Start a new game
func (g *MinesweeperGrid) NewGame() <span class="cov8" title="1">{
        slog.Info("Preparing for new game")
        g.Game = nil
        g.Reset()
}</span>

// Replay the current game
func (g *MinesweeperGrid) Replay() <span class="cov8" title="1">{
        slog.Info("Preparing for replay of current game")
        if g.Game != nil </span><span class="cov8" title="1">{
                g.Game.Replay()
        }</span>
        <span class="cov8" title="1">g.Reset()</span>
}

// Reset Grid
func (g *MinesweeperGrid) Reset() <span class="cov8" title="1">{
        for x := 0; x &lt; g.Row(); x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; g.Col(); y++ </span><span class="cov8" title="1">{
                        g.Tiles[x][y].Reset()
                }</span>
        }
        <span class="cov8" title="1">g.MineCount.SetCount(g.Difficulty.Mines)
        g.Timer.Reset()
        g.ResetButton.SetText(ResetDefaultText)
        g.ResetButton.Refresh()
        slog.Debug("Reset grid")</span>
}

// Check if the given position is out of bounds.
// Calls Game.OutOfBounds(Pos)
func (g *MinesweeperGrid) OutOfBounds(p minesweeper.Pos) bool <span class="cov8" title="1">{
        return g.Game.OutOfBounds(p)
}</span>

// Display a single hint on the grid.
// Returns false if no hint could be displayed.
func (g *MinesweeperGrid) Hint() bool <span class="cov8" title="1">{
        if g.Game == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">s := g.Game.Status()
        if s.GameOver || s.GameWon </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, mine := range s.ObviousMines() </span><span class="cov8" title="1">{
                tile := g.Tiles[mine.X][mine.Y]
                if tile.Flagged </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">tile.Marker = HelpMarkingMine
                tile.UpdateContent()
                return true</span>
        }
        <span class="cov8" title="1">safePos := s.ObviousSafePos()
        if len(safePos) &gt; 0 </span><span class="cov8" title="1">{
                tile := g.Tiles[safePos[0].X][safePos[0].Y]
                tile.Marker = HelpMarkingSafe
                tile.UpdateContent()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "log/slog"
        "os"
)

const logLevel = slog.LevelError

func init() <span class="cov8" title="1">{
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">//go:generate fyne bundle --package assets --prefix Resource -o ../../assets/bundle_generated.go ../../img/mine.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag.png
//go:generate fyne bundle --prefix Resource -o ../../assets/bundle_generated.go -append ../../img/flag-success.png
package app

import (
        "image/color"
        "strconv"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/go-minesweeper/assets"
        "github.com/heathcliff26/go-minesweeper/pkg/minesweeper"
)

var (
        TileDefaultColor    = color.Gray16{32767}
        TileBackgroundColor = color.Gray16{^uint16(0)}
        TileExplodedColor   = color.RGBA{240, 10, 20, alpha}

        TileSize             = fyne.NewSize(32, 32)
        TileTextSize float32 = 23 // Biggest we can go with TileSize of 32^2
)

const alpha = ^uint8(0)

type HelpMarking int

const (
        HelpMarkingNone HelpMarking = iota
        HelpMarkingMine
        HelpMarkingSafe
)

var (
        HelperMarkerSymbols = []string{"", "!", "?"}
        HelperMarkerColors  = []color.Color{
                color.White,
                color.RGBA{180, 15, 15, alpha}, // Mine, red
                color.RGBA{15, 180, 15, alpha}, // Safe, green
        }
)

var TileTextColor = []color.Color{
        color.White,
        color.RGBA{20, 15, 220, alpha},  // 1, blue
        color.RGBA{5, 110, 20, alpha},   // 2, green
        color.RGBA{240, 10, 20, alpha},  // 3, red
        color.RGBA{5, 5, 100, alpha},    // 4, dark blue
        color.RGBA{90, 38, 42, alpha},   // 5, brown
        color.RGBA{25, 230, 230, alpha}, // 6, cyan
        color.RGBA{10, 10, 10, alpha},   // 7, black
        color.RGBA{64, 64, 64, alpha},   // 8, grey
}

// A tile extends the base widget and displays the current state of the backing games field
type Tile struct {
        widget.BaseWidget

        background *canvas.Rectangle
        label      *canvas.Text
        icon       *widget.Icon

        Pos     minesweeper.Pos
        Field   *minesweeper.Field
        grid    *MinesweeperGrid
        Flagged bool
        Marker  HelpMarking
}

// Create a new Tile with a reference to it's parent grid, as well as knowledge of it's own position in the Grid
func NewTile(x, y int, grid *MinesweeperGrid) *Tile <span class="cov8" title="1">{
        t := &amp;Tile{
                Pos: minesweeper.NewPos(x, y),
                Field: &amp;minesweeper.Field{
                        Checked: false,
                        Content: minesweeper.Unknown,
                },
                grid: grid,
        }
        t.ExtendBaseWidget(t)

        return t
}</span>

// Function to create renderer needed to implement widget
func (t *Tile) CreateRenderer() fyne.WidgetRenderer <span class="cov8" title="1">{
        t.ExtendBaseWidget(t)

        t.background = canvas.NewRectangle(TileDefaultColor)
        t.background.SetMinSize(TileSize)

        t.label = canvas.NewText("", color.White)
        t.label.TextStyle.Bold = true
        t.label.Alignment = fyne.TextAlignCenter
        t.label.TextSize = TileTextSize
        t.label.Hidden = true

        t.icon = widget.NewIcon(nil)
        t.icon.Resize(TileSize)
        t.icon.Hidden = true

        content := container.NewStack(t.background, t.icon, t.label)
        return widget.NewSimpleRenderer(content)
}</span>

// Left mouse click on tile
func (t *Tile) Tapped(_ *fyne.PointEvent) <span class="cov8" title="1">{
        if t.untappable() || t.Flagged </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.grid.TappedTile(t.Pos)</span>
}

// Right mouse click on tile
func (t *Tile) TappedSecondary(_ *fyne.PointEvent) <span class="cov8" title="1">{
        if t.untappable() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if t.Flagged </span><span class="cov8" title="1">{
                t.grid.MineCount.Inc()
        }</span> else<span class="cov8" title="1"> {
                t.grid.MineCount.Dec()
        }</span>
        <span class="cov8" title="1">t.Flagged = !t.Flagged
        t.UpdateContent()</span>
}

// Double click on tile
func (t *Tile) DoubleTapped(_ *fyne.PointEvent) <span class="cov8" title="1">{
        if !t.Field.Checked || t.gameFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">flags := minesweeper.FieldContent(0)
        posToCheck := make([]minesweeper.Pos, 0, 8)
        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        p := t.Pos
                        p.X += m
                        p.Y += n
                        if !t.grid.OutOfBounds(p) </span><span class="cov8" title="1">{
                                if t.grid.Tiles[p.X][p.Y].Flagged </span><span class="cov8" title="1">{
                                        flags++
                                        continue</span>
                                }
                                <span class="cov8" title="1">if t.grid.Tiles[p.X][p.Y].untappable() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">posToCheck = append(posToCheck, p)</span>
                        }
                }
        }

        <span class="cov8" title="1">if flags == t.Field.Content </span><span class="cov8" title="1">{
                var status *minesweeper.Status
                for _, p := range posToCheck </span><span class="cov8" title="1">{
                        status = t.grid.Game.CheckField(p)
                }</span>
                <span class="cov8" title="1">t.grid.updateFromStatus(status)</span>
        }
}

// Update the tile render depending on the current state of it's backing Field
func (t *Tile) UpdateContent() <span class="cov8" title="1">{
        t.icon.Hidden = true
        t.label.Hidden = true
        t.background.FillColor = TileDefaultColor
        defer t.Refresh()

        switch </span>{
        case t.Flagged &amp;&amp; !t.Field.Checked:<span class="cov8" title="1">
                if t.Field.Content == minesweeper.Mine </span><span class="cov8" title="1">{
                        t.icon.SetResource(assets.ResourceFlagSuccessPng)
                }</span> else<span class="cov8" title="1"> {
                        t.icon.SetResource(assets.ResourceFlagPng)
                }</span>
                <span class="cov8" title="1">t.icon.Hidden = false</span>
        case t.Marker != HelpMarkingNone &amp;&amp; !t.Flagged &amp;&amp; !t.Field.Checked &amp;&amp; t.Field.Content == minesweeper.Unknown:<span class="cov8" title="1">
                t.label.Text = HelperMarkerSymbols[t.Marker]
                t.label.Color = HelperMarkerColors[t.Marker]
                t.label.Hidden = false</span>
        case t.Field.Content == minesweeper.Mine:<span class="cov8" title="1">
                t.icon.SetResource(assets.ResourceMinePng)
                t.icon.Hidden = false
                if t.Field.Checked </span><span class="cov8" title="1">{
                        t.background.FillColor = TileExplodedColor
                }</span>
        case t.Field.Checked &amp;&amp; t.Field.Content &gt; 0 &amp;&amp; t.Field.Content &lt; 9:<span class="cov8" title="1">
                t.label.Text = strconv.Itoa(int(t.Field.Content))
                t.label.Color = TileTextColor[t.Field.Content]
                t.label.Hidden = false
                t.background.FillColor = TileBackgroundColor</span>
        case t.Field.Checked:<span class="cov8" title="1">
                t.background.FillColor = TileBackgroundColor</span>
        }
}

// Reset tile to default state, used for starting new game
func (t *Tile) Reset() <span class="cov8" title="1">{
        t.Flagged = false
        t.Field.Checked = false
        t.Field.Content = minesweeper.Unknown
        t.Marker = HelpMarkingNone
        t.UpdateContent()
}</span>

// Check if the tile should be clickable
func (t *Tile) untappable() bool <span class="cov8" title="1">{
        return t.Field.Checked || t.gameFinished()
}</span>

// Check if game is finished
func (t *Tile) gameFinished() bool <span class="cov8" title="1">{
        if t.grid.Game != nil </span><span class="cov8" title="1">{
                return t.grid.Game.Lost() || t.grid.Game.Won()
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "fmt"
        "log/slog"
        "time"

        "fyne.io/fyne/v2/canvas"
)

// Timer to display an upwards countdown in a fyne app.
type Timer struct {
        Label   *canvas.Text
        Seconds int
        stop    chan bool
        running bool
}

// Create new timer
func NewTimer() *Timer <span class="cov8" title="1">{
        return &amp;Timer{
                Label:   newGridLabel("0000"),
                Seconds: 0,
                stop:    make(chan bool),
        }
}</span>

// Start the timer, runs concurrently
func (t *Timer) Start() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Second)
        t.running = true
        go func() </span><span class="cov8" title="1">{
                slog.Debug("Started timer")
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-t.stop:<span class="cov8" title="1">
                                ticker.Stop()
                                slog.Info("Stopped timer", slog.Int("seconds", t.Seconds))
                                return</span>
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                t.Seconds++
                                t.refresh()</span>
                        }
                }
        }()
}

// Stop the timer
func (t *Timer) Stop() <span class="cov8" title="1">{
        if t.Running() </span><span class="cov8" title="1">{
                t.stop &lt;- true
                t.running = false
        }</span>
}

// Reset the timer back to zero
func (t *Timer) Reset() <span class="cov8" title="1">{
        t.Stop()
        t.Seconds = 0
        t.refresh()
}</span>

// Check if the timer is running
func (t *Timer) Running() bool <span class="cov8" title="1">{
        return t.running
}</span>

// Refresh the timer from it's current values
func (t *Timer) refresh() <span class="cov8" title="1">{
        t.Label.Text = fmt.Sprintf("%04d", t.Seconds)
        t.Label.Refresh()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "image/color"
        "os"
        "path/filepath"
        "runtime"
        "runtime/debug"
        "strings"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/storage"
)

// Struct for containing the current version of the app
type Version struct {
        Name, Version, Commit, Go string
}

// Extract the version information from app
func getVersion(app fyne.App) Version <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov0" title="0">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span>

        <span class="cov8" title="1">metadata := app.Metadata()

        name, _ := strings.CutSuffix(metadata.Name, ".exe")
        if name == "" </span><span class="cov8" title="1">{
                name = filepath.Base(os.Args[0])
        }</span>

        <span class="cov8" title="1">return Version{
                Name:    name,
                Version: "v" + metadata.Version,
                Commit:  commit,
                Go:      runtime.Version(),
        }</span>
}

// Create the content for the version dialog
func getVersionContent(v Version) fyne.CanvasObject <span class="cov0" title="0">{
        r1 := make([]fyne.CanvasObject, 3)
        r2 := make([]fyne.CanvasObject, 3)
        r1[0] = canvas.NewText("Version:", TEXT_COLOR)
        r2[0] = canvas.NewText(v.Version, TEXT_COLOR)
        r1[1] = canvas.NewText("Commit:", TEXT_COLOR)
        r2[1] = canvas.NewText(v.Commit, TEXT_COLOR)
        r1[2] = canvas.NewText("Go:", TEXT_COLOR)
        r2[2] = canvas.NewText(v.Go, TEXT_COLOR)

        row1 := container.NewVBox(r1...)
        row2 := container.NewVBox(r2...)

        return container.NewPadded(container.NewHBox(row1, row2))
}</span>

// Create a line for the border
func makeBorderStrip() fyne.CanvasObject <span class="cov8" title="1">{
        rec := canvas.NewRectangle(color.White)
        rec.SetMinSize(fyne.NewSize(1, 1))
        return rec
}</span>

// Wrap the objects in a box with border lines
func newBorder(content ...fyne.CanvasObject) fyne.CanvasObject <span class="cov8" title="1">{
        top := makeBorderStrip()
        left := makeBorderStrip()
        bottom := makeBorderStrip()
        right := makeBorderStrip()
        border := container.NewBorder(top, bottom, left, right, content...)
        return container.NewPadded(border)
}</span>

// Create a new label used in the grid, with preset color, text size and text style
func newGridLabel(text string) *canvas.Text <span class="cov8" title="1">{
        label := canvas.NewText(text, GridLabelColor)
        label.TextSize = GridLabelSize
        label.TextStyle.Bold = true
        return label
}</span>

// Set a file dialogs location to the current directory.
// Return indicates if the operation was successfull.
// Shows error dialog on failure.
func setDialogLocationToPWD(d *dialog.FileDialog, window fyne.Window) bool <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, window)
                return false
        }</span>
        <span class="cov0" title="0">uri, err := storage.ParseURI("file://" + dir)
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, window)
                return false
        }</span>
        <span class="cov0" title="0">listURI, err := storage.ListerForURI(uri)
        if err != nil </span><span class="cov0" title="0">{
                dialog.ShowError(err, window)
                return false
        }</span>
        <span class="cov0" title="0">d.SetLocation(listURI)

        return true</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package minesweeper

const (
        DifficultyClassic      = iota
        DifficultyBeginner     = iota
        DifficultyIntermediate = iota
        DifficultyExpert       = iota
)

const (
        DifficultyRowColMin         = 8
        DifficultyRowColMax         = 99
        DifficultyMineMin           = 9
        DifficultyMineMaxPercentage = 0.8
)

// Represent a difficulty setting for the Game
type Difficulty struct {
        Name     string
        Row, Col int
        Mines    int
}

// Pre-defined difficulties
var difficulties []Difficulty = []Difficulty{
        {
                Name:  "Classic",
                Row:   8,
                Col:   8,
                Mines: 9,
        },
        {
                Name:  "Beginner",
                Row:   9,
                Col:   9,
                Mines: 10,
        },
        {
                Name:  "Intermediate",
                Row:   16,
                Col:   16,
                Mines: 40,
        },
        {
                Name:  "Expert",
                Row:   16,
                Col:   30,
                Mines: 99,
        },
}

// Exposes pre-defined difficulties in a way that does not allow the original array to be modified
func Difficulties() []Difficulty <span class="cov8" title="1">{
        list := make([]Difficulty, len(difficulties))
        copy(list, difficulties)
        return list
}</span>

func NewCustomDifficulty(mines, row, col int) (Difficulty, error) <span class="cov8" title="1">{
        if row &lt; DifficultyRowColMin || row &gt; DifficultyRowColMax || col &lt; DifficultyRowColMin || col &gt; DifficultyRowColMax </span><span class="cov8" title="1">{
                return Difficulty{}, NewErrDifficultyDimension(row, col)
        }</span>
        <span class="cov8" title="1">if mines &lt; DifficultyMineMin || float64(mines) &gt; float64(row*col)*DifficultyMineMaxPercentage </span><span class="cov8" title="1">{
                return Difficulty{}, NewErrDifficultyMineCount(mines)
        }</span>
        <span class="cov8" title="1">return Difficulty{
                Name:  "Custom",
                Row:   row,
                Col:   col,
                Mines: mines,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package minesweeper

import "fmt"

type ErrDifficultyDimension struct {
        row int
        col int
}

func NewErrDifficultyDimension(row, col int) error <span class="cov8" title="1">{
        return &amp;ErrDifficultyDimension{row, col}
}</span>

func (e *ErrDifficultyDimension) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Rows and Columns need to be between %d and %d, got %dx%d", DifficultyRowColMin, DifficultyRowColMax, e.row, e.col)
}</span>

type ErrDifficultyMineCount struct {
        mines int
}

func NewErrDifficultyMineCount(mines int) error <span class="cov8" title="1">{
        return &amp;ErrDifficultyMineCount{mines}
}</span>

func (e *ErrDifficultyMineCount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("The number of mines need to be between %d and %.1f %% of the total number of cells, got %d", DifficultyMineMin, DifficultyMineMaxPercentage*100, e.mines)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package minesweeper

import (
        "log/slog"

        "github.com/heathcliff26/go-minesweeper/pkg/utils"
)

// Represents the content of a field.
// Can be a mine, unknown or the number of mines in the neighboring fields
type FieldContent int

const (
        Mine    FieldContent = -1
        Unknown FieldContent = -2
)

// Represents a single field in a minefield
type Field struct {
        Checked bool
        Content FieldContent
}

// Interface for playing the game
type Game interface {
        // Check a given field and recursevly reveal all neighboring fields that should be revield.
        // Returns the resulting new status of the game
        CheckField(p Pos) *Status
        // Recursive function to reveal all neighbouring fields that can be safely reveald.
        // Stops when a field has not exactly zero neighbouring mines
        RevealField(p Pos)
        // Check if the given position is out of bounds
        OutOfBounds(p Pos) bool
        // Returns the current status of the game. Only contains the knowledge a player should have.
        Status() *Status
        // Check if Game Over
        Lost() bool
        // Check if the game is won
        Won() bool
        // Reset the current game to be played again
        Replay()
        // Check if the game is a replay
        IsReplay() bool
        // Generate a save from the game
        ToSave() (*Save, error)
}

type LocalGame struct {
        Field      [][]Field
        Difficulty Difficulty

        // Keep these 2 exported for testing in other packages
        GameOver bool
        GameWon  bool

        // Cache the last status
        status *Status

        replay bool
}

// Utility function to create empty game
func blankGame(d Difficulty) *LocalGame <span class="cov8" title="1">{
        return &amp;LocalGame{
                Field:      utils.Make2D[Field](d.Row, d.Col),
                Difficulty: d,
                GameOver:   false,
                GameWon:    false,
        }
}</span>

// Create a new game with the mines in the given positions
func newGame(d Difficulty, mines []Pos) *LocalGame <span class="cov8" title="1">{
        g := blankGame(d)

        for _, mine := range mines </span><span class="cov8" title="1">{
                g.Field[mine.X][mine.Y].Content = Mine
        }</span>

        <span class="cov8" title="1">g.calculateFieldContent()

        return g</span>
}

// Create a new game with mines seeded randomly in the map, with the exception of the given position.
func NewGameWithSafePos(d Difficulty, p Pos) *LocalGame <span class="cov8" title="1">{
        mines := CreateMines(d, []Pos{p})

        return newGame(d, mines)
}</span>

// Create a new game with mines seeded randomly in the map, with the exception of a 3x3 area around the given position.
func NewGameWithSafeArea(d Difficulty, p Pos) *LocalGame <span class="cov8" title="1">{
        area := make([]Pos, 0, 9)
        for x := -1; x &lt; 2; x++ </span><span class="cov8" title="1">{
                for y := -1; y &lt; 2; y++ </span><span class="cov8" title="1">{
                        p := NewPos(p.X+x, p.Y+y)
                        if !OutOfBounds(p, d) </span><span class="cov8" title="1">{
                                area = append(area, p)
                        }</span>
                }
        }
        <span class="cov8" title="1">mines := CreateMines(d, area)

        return newGame(d, mines)</span>
}

// Check a given field and recursevly reveal all neighboring fields that should be revield.
// Returns the resulting new status of the game
func (g *LocalGame) CheckField(p Pos) *Status <span class="cov8" title="1">{
        if g.Lost() || g.Won() </span><span class="cov8" title="1">{
                return g.Status()
        }</span>

        <span class="cov8" title="1">g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content == Mine </span><span class="cov8" title="1">{
                g.GameOver = true
                g.UpdateStatus()
                return g.Status()
        }</span>

        <span class="cov8" title="1">g.RevealField(p)

        g.UpdateStatus()
        return g.Status()</span>
}

// Recursive function to reveal all neighbouring fields that can be safely reveald.
// Stops when a field has not exactly zero neighbouring mines
func (g *LocalGame) RevealField(p Pos) <span class="cov8" title="1">{
        slog.Debug("Reveal field", slog.String("pos", p.String()), slog.String("content", g.Field[p.X][p.Y].Content.String()))

        g.Field[p.X][p.Y].Checked = true

        if g.Field[p.X][p.Y].Content != 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Revealing fields neigbhours", slog.String("pos", p.String()))

        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        if m == 0 &amp;&amp; n == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">i := NewPos(p.X+m, p.Y+n)
                        if g.OutOfBounds(i) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if !g.Field[i.X][i.Y].Checked </span><span class="cov8" title="1">{
                                g.RevealField(i)
                        }</span>
                }
        }
}

// Check if the given position is out of bounds
func (g *LocalGame) OutOfBounds(p Pos) bool <span class="cov8" title="1">{
        return OutOfBounds(p, g.Difficulty)
}</span>

// Returns the current status of the game. Only contains the knowledge a player should have.
func (g *LocalGame) Status() *Status <span class="cov8" title="1">{
        return g.status
}</span>

// Create a new instance of status
func (g *LocalGame) UpdateStatus() <span class="cov8" title="1">{
        d := g.Difficulty
        s := &amp;Status{
                Field:    utils.Make2D[Field](d.Row, d.Col),
                GameOver: g.Lost(),
                GameWon:  g.Won(),
        }

        wasWon := g.Won()
        isWon := true

        g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                s.Field[x][y].Checked = g.Field[x][y].Checked
                if g.Field[x][y].Checked || g.Lost() || g.Won() </span><span class="cov8" title="1">{
                        s.Field[x][y].Content = g.Field[x][y].Content
                }</span> else<span class="cov8" title="1"> {
                        s.Field[x][y].Content = Unknown
                }</span>
                <span class="cov8" title="1">if !g.Field[x][y].Checked &amp;&amp; g.Field[x][y].Content != Mine </span><span class="cov8" title="1">{
                        isWon = false
                }</span>
        })

        <span class="cov8" title="1">if !wasWon &amp;&amp; isWon </span><span class="cov8" title="1">{
                g.GameWon, s.GameWon = isWon, isWon
                for x := 0; x &lt; d.Row; x++ </span><span class="cov8" title="1">{
                        copy(s.Field[x], g.Field[x])
                }</span>
        }

        <span class="cov8" title="1">g.status = s</span>
}

// Check if Game Over
func (g *LocalGame) Lost() bool <span class="cov8" title="1">{
        return g.GameOver
}</span>

// Check if the game is won
func (g *LocalGame) Won() bool <span class="cov8" title="1">{
        return g.GameWon
}</span>

// Reset the current game to be played again
func (g *LocalGame) Replay() <span class="cov8" title="1">{
        g.replay = true
        g.GameOver = false
        g.GameWon = false

        g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                g.Field[x][y].Checked = false
        }</span>)
}

// Check if the game is a replay
func (g *LocalGame) IsReplay() bool <span class="cov8" title="1">{
        return g.replay
}</span>

// Generate a save from the game
func (g *LocalGame) ToSave() (*Save, error) <span class="cov8" title="1">{
        g.replay = true
        return NewSave(g)
}</span>

// Walk through all fields of the game and call the given function
func (g *LocalGame) walkField(f func(x, y int)) <span class="cov8" title="1">{
        walkField(f, g.Difficulty.Row, g.Difficulty.Col)
}</span>

// Count the the number of mines in the neighboring fields
func (g *LocalGame) countNearbyMines(p Pos) int <span class="cov8" title="1">{
        c := 0
        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                        if g.OutOfBounds(NewPos(p.X+m, p.Y+n)) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if g.Field[p.X+m][p.Y+n].Content == Mine </span><span class="cov8" title="1">{
                                c++
                        }</span>
                }
        }
        <span class="cov8" title="1">return c</span>
}

// Get a list of all mines in the game
func (g *LocalGame) getMines() []Pos <span class="cov8" title="1">{
        mines := make([]Pos, 0, g.Difficulty.Mines)

        g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                if g.Field[x][y].Content == Mine </span><span class="cov8" title="1">{
                        mines = append(mines, NewPos(x, y))
                }</span>
        })
        <span class="cov8" title="1">return mines</span>
}

// Calculate all fields with the count of neighbouring mines
func (g *LocalGame) calculateFieldContent() <span class="cov8" title="1">{
        g.walkField(func(x, y int) </span><span class="cov8" title="1">{
                if g.Field[x][y].Content == Mine </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">g.Field[x][y].Content = FieldContent(g.countNearbyMines(NewPos(x, y)))</span>
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package minesweeper

import (
        "crypto/sha512"
        "encoding/hex"
        "encoding/json"
        "os"
        "path/filepath"
)

const SaveFileExtension = ".sav"

type Save struct {
        // ID is the hash generated from the Data
        ID string `json:"id"`
        // Data contains everything necessary to create a game
        Data saveData `json:"data"`
}

type saveData struct {
        Mines      []Pos      `json:"mines"`
        Difficulty Difficulty `json:"difficulty"`
}

// Create a new save from the given game
func NewSave(game *LocalGame) (*Save, error) <span class="cov8" title="1">{
        data := saveData{
                Mines:      game.getMines(),
                Difficulty: game.Difficulty,
        }

        buf, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">hash := sha512.Sum512(buf)

        return &amp;Save{
                ID:   hex.EncodeToString(hash[:]),
                Data: data,
        }, nil</span>
}

// Load a save file from the given path
func LoadSave(path string) (*Save, error) <span class="cov8" title="1">{
        buf, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var save Save
        err = json.Unmarshal(buf, &amp;save)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;save, nil</span>
}

// Write save file to the given path.
// Needs to have the correct extension.
func (s *Save) Save(path string) error <span class="cov8" title="1">{
        if filepath.Ext(path) != SaveFileExtension </span><span class="cov8" title="1">{
                path += SaveFileExtension
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(s, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}

// Creates a LocalGame from the save.
// The game will be considered a replay
func (s *Save) Game() *LocalGame <span class="cov8" title="1">{
        g := blankGame(s.Data.Difficulty)

        for _, p := range s.Data.Mines </span><span class="cov8" title="1">{
                g.Field[p.X][p.Y].Content = Mine
        }</span>

        <span class="cov8" title="1">g.calculateFieldContent()

        g.replay = true

        return g</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package minesweeper

import (
        "log/slog"
        "slices"
)

// Status contains the current state of the game known to the player.
// As such it will always be a copy and needs to be it's own type, despite the
// overlapping similarities.
// It does not support any of the functions that Game does.
// It is safe to write to Status, as it is merely a copy.
type Status struct {
        Field    [][]Field
        GameOver bool
        GameWon  bool

        actions Actions
}

type Actions struct {
        Mines   []Pos
        SafePos []Pos
}

func (s *Status) ObviousMines() []Pos <span class="cov8" title="1">{
        if s.actions.Mines == nil </span><span class="cov8" title="1">{
                s.createActions()
        }</span>
        <span class="cov8" title="1">return s.actions.Mines</span>
}

func (s *Status) ObviousSafePos() []Pos <span class="cov8" title="1">{
        if s.actions.SafePos == nil </span><span class="cov8" title="1">{
                s.createActions()
        }</span>
        <span class="cov8" title="1">return s.actions.SafePos</span>
}

func (s *Status) createActions() <span class="cov8" title="1">{
        s.actions = Actions{
                Mines:   make([]Pos, 0, 10),
                SafePos: make([]Pos, 0, 10),
        }
        if len(s.Field) == 0 || s.GameOver || s.GameWon </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">d := Difficulty{
                Row: len(s.Field),
                Col: len(s.Field[0]),
        }

        i := 0
        oldLenMines := -1
        oldLenSafe := -1
        for len(s.actions.Mines) &gt; oldLenMines || len(s.actions.SafePos) &gt; oldLenSafe </span><span class="cov8" title="1">{
                i++
                oldLenMines = len(s.actions.Mines)
                oldLenSafe = len(s.actions.SafePos)
                walkField(func(x, y int) </span><span class="cov8" title="1">{
                        if !s.Field[x][y].Checked || s.Field[x][y].Content &lt;= 0 </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">unchecked := FieldContent(0)
                        mines := unchecked
                        newPos := make([]Pos, 0, 8)
                        for m := -1; m &lt; 2; m++ </span><span class="cov8" title="1">{
                                for n := -1; n &lt; 2; n++ </span><span class="cov8" title="1">{
                                        p := NewPos(x+m, y+n)
                                        if OutOfBounds(p, d) </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if !s.Field[p.X][p.Y].Checked </span><span class="cov8" title="1">{
                                                unchecked++
                                                if slices.Contains(s.actions.Mines, p) </span><span class="cov8" title="1">{
                                                        mines++
                                                }</span> else<span class="cov8" title="1"> if !slices.Contains(s.actions.SafePos, p) </span><span class="cov8" title="1">{
                                                        newPos = append(newPos, p)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if len(newPos) == 0 </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">if unchecked == s.Field[x][y].Content &amp;&amp; mines != s.Field[x][y].Content </span><span class="cov8" title="1">{
                                slog.Debug("Assisted Mode: Found mines near field",
                                        slog.String("pos", NewPos(x, y).String()),
                                        slog.Int("mines", int(mines)),
                                        slog.Int("unchecked", int(unchecked)),
                                        slog.Int("content", int(s.Field[x][y].Content)),
                                        slog.Any("newPos", newPos),
                                )
                                s.actions.Mines = append(s.actions.Mines, newPos...)
                        }</span> else<span class="cov8" title="1"> if mines == s.Field[x][y].Content &amp;&amp; unchecked &gt; s.Field[x][y].Content </span><span class="cov8" title="1">{
                                slog.Debug("Assisted Mode: Found safe positions near field",
                                        slog.String("pos", NewPos(x, y).String()),
                                        slog.Int("mines", int(mines)),
                                        slog.Int("unchecked", int(unchecked)),
                                        slog.Int("content", int(s.Field[x][y].Content)),
                                        slog.Any("newPos", newPos),
                                )
                                s.actions.SafePos = append(s.actions.SafePos, newPos...)
                        }</span>
                }, d.Row, d.Col)
        }

        <span class="cov8" title="1">slog.Debug("Assisted Mode: Mines and safe Positions found", slog.Any("mines", s.actions.Mines), slog.Any("safe", s.actions.SafePos), slog.Int("iterations", i))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package minesweeper

import (
        "fmt"
        "math/rand/v2"
        "slices"
        "strconv"
)

// Represent a position in the minefield
type Pos struct {
        X, Y int
}

// Create a new Position from the given coordinates
func NewPos(x, y int) Pos <span class="cov8" title="1">{
        return Pos{x, y}
}</span>

// Returns a random position inside the provided limits
func RandomPos(maxX, maxY int) Pos <span class="cov8" title="1">{
        return NewPos(rand.IntN(maxX), rand.IntN(maxY))
}</span>

// Returns a string representation of the position
func (p Pos) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}</span>

// Randomly create mines for the given difficulty.
// Does not create a mine on the given positions.
func CreateMines(d Difficulty, safe []Pos) []Pos <span class="cov8" title="1">{
        var p Pos
        mines := make([]Pos, 0, d.Mines+len(safe))

        mines = append(mines, safe...)
        for i := 0; i &lt; d.Mines; i++ </span><span class="cov8" title="1">{
                p = RandomPos(d.Row, d.Col)
                for slices.Contains(mines, p) </span><span class="cov8" title="1">{
                        p = RandomPos(d.Row, d.Col)
                }</span>
                <span class="cov8" title="1">mines = append(mines, p)</span>
        }
        <span class="cov8" title="1">return mines[len(safe):]</span>
}

// Convert FieldContent to string for logging
func (fc FieldContent) String() string <span class="cov8" title="1">{
        switch </span>{
        case fc == Mine:<span class="cov8" title="1">
                return "Mine"</span>
        case fc == Unknown:<span class="cov8" title="1">
                return "Unknown"</span>
        case fc &gt;= 0 &amp;&amp; fc &lt; 9:<span class="cov8" title="1">
                return strconv.Itoa(int(fc))</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%d is not a valid FieldContent", fc)</span>
        }
}

// Check if a position is out of bounds on the given difficulty
func OutOfBounds(p Pos, d Difficulty) bool <span class="cov8" title="1">{
        return p.X &lt; 0 || p.X &gt; d.Row-1 || p.Y &lt; 0 || p.Y &gt; d.Col-1
}</span>

// Walk through all fields in the given dimension and call the given function
func walkField(f func(x, y int), limitX, limitY int) <span class="cov8" title="1">{
        for x := 0; x &lt; limitX; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; limitY; y++ </span><span class="cov8" title="1">{
                        f(x, y)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package utils

// Create a new, empty 2 dimensional array of the given type and dimensions.
func Make2D[T any](x, y int) [][]T <span class="cov8" title="1">{
        if x &lt; 1 || y &lt; 1 </span><span class="cov8" title="1">{
                return [][]T{}
        }</span>

        <span class="cov8" title="1">matrix := make([][]T, x)
        rows := make([]T, x*y)

        for i := 0; i &lt; x; i++ </span><span class="cov8" title="1">{
                matrix[i] = rows[i*y : (i+1)*y]
        }</span>
        <span class="cov8" title="1">return matrix</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
